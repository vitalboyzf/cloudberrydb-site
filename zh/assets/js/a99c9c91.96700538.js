"use strict";(self.webpackChunkApache_Cloudberry_Incubating_website=self.webpackChunkApache_Cloudberry_Incubating_website||[]).push([[5290],{12771:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>o,toc:()=>l});var s=t(85893),i=t(11151);const a={title:"CREATE FUNCTION"},r="CREATE FUNCTION",o={id:"sql-stmts/create-function",title:"CREATE FUNCTION",description:"Defines a new function.",source:"@site/docs/sql-stmts/create-function.md",sourceDirName:"sql-stmts",slug:"/sql-stmts/create-function",permalink:"/zh/docs/sql-stmts/create-function",draft:!1,unlisted:!1,editUrl:"https://github.com/apache/cloudberry-site/edit/main/docs/sql-stmts/create-function.md",tags:[],version:"current",lastUpdatedBy:"Dianjin Wang",lastUpdatedAt:1740637488,formattedLastUpdatedAt:"2025\u5e742\u670827\u65e5",frontMatter:{title:"CREATE FUNCTION"},sidebar:"docsbars",previous:{title:"CREATE FOREIGN TABLE",permalink:"/zh/docs/sql-stmts/create-foreign-table"},next:{title:"CREATE GROUP",permalink:"/zh/docs/sql-stmts/create-group"}},c={},l=[{value:"Synopsis",id:"synopsis",level:2},{value:"Description",id:"description",level:2},{value:"Parameters",id:"parameters",level:2},{value:"Overloading",id:"overloading",level:2},{value:"Notes",id:"notes",level:2},{value:"Examples",id:"examples",level:2},{value:"Writing security definer functions safely",id:"writing-security-definer-functions-safely",level:2},{value:"Compatibility",id:"compatibility",level:2},{value:"See also",id:"see-also",level:2}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"create-function",children:"CREATE FUNCTION"}),"\n",(0,s.jsx)(n.p,{children:"Defines a new function."}),"\n",(0,s.jsx)(n.h2,{id:"synopsis",children:"Synopsis"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"CREATE [OR REPLACE] FUNCTION <name>\xa0\xa0\xa0\xa0\n    ( [ [<argmode>] [<argname>] <argtype> [ { DEFAULT | = } <default_expr> ] [, ...] ] )\n\xa0\xa0\xa0\xa0\xa0\xa0[ RETURNS <rettype> \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0| RETURNS TABLE ( <column_name> <column_type> [, ...] ) ]\n\xa0\xa0{ LANGUAGE <lang_name>\n    | TRANSFORM { FOR TYPE <type_name> } [, ... ]\n    | WINDOW\n\xa0\xa0\xa0\xa0| { IMMUTABLE | STABLE | VOLATILE }\n    | [ NOT ] LEAKPROOF\n\xa0\xa0\xa0\xa0| { CALLED ON NULL INPUT | RETURNS NULL ON NULL INPUT | STRICT }\n\xa0\xa0\xa0\xa0| { [ EXTERNAL ] SECURITY INVOKER | [ EXTERNAL ] SECURITY DEFINER }\n\xa0\xa0\xa0\xa0| EXECUTE ON { ANY | COORDINATOR | ALL SEGMENTS | INITPLAN }\n    | PARALLEL { UNSAFE | RESTRICTED | SAFE }\n\xa0\xa0\xa0\xa0| COST <execution_cost>\n    | ROWS <result_rows>\n    | SUPPORT <support_function>\n\xa0\xa0\xa0\xa0| SET <configuration_parameter> { TO <value> | = <value> | FROM CURRENT }\n    | AS '<definition>'\n\xa0\xa0\xa0\xa0| AS '<obj_file>', '<link_symbol>' \n    [ WITH ({ DESCRIBE = <describe_function> } [, ...] ) ]\n  } ...\n"})}),"\n",(0,s.jsx)(n.h2,{id:"description",children:"Description"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"CREATE FUNCTION"})," defines a new function. ",(0,s.jsx)(n.code,{children:"CREATE OR REPLACE FUNCTION"})," either creates a new function, or replaces an existing definition. To define a function, the user must have the ",(0,s.jsx)(n.code,{children:"USAGE"})," privilege on the language."]}),"\n",(0,s.jsx)(n.p,{children:"If a schema name is included, then the function is created in the specified schema. Otherwise it is created in the current schema. The name of the new function must not match any existing function with the same input argument types in the same schema. However, functions of different argument types may share a name (overloading)."}),"\n",(0,s.jsxs)(n.p,{children:["To update the current definition of an existing function, use ",(0,s.jsx)(n.code,{children:"CREATE OR REPLACE FUNCTION"}),". It is not possible to change the name or argument types of a function this way (this would actually create a new, distinct function). Also, ",(0,s.jsx)(n.code,{children:"CREATE OR REPLACE FUNCTION"})," will not let you change the return type of an existing function. To do that, you must drop and recreate the function. (When using ",(0,s.jsx)(n.code,{children:"OUT"})," parameters, that means you cannot change the types of any ",(0,s.jsx)(n.code,{children:"OUT"})," parameters except by dropping the function.)"]}),"\n",(0,s.jsxs)(n.p,{children:["When ",(0,s.jsx)(n.code,{children:"CREATE OR REPLACE FUNCTION"})," is used to replace an existing function, the ownership and permissions of the function do not change. All other function properties are assigned the values specified or implied in the command. You must own the function to replace it (this includes being a member of the owning role)."]}),"\n",(0,s.jsxs)(n.p,{children:["If you drop and then recreate a function, the new function is not the same entity as the old; you will have to drop existing objects (rules, views, triggers, and so on) that refer to the old function. Use ",(0,s.jsx)(n.code,{children:"CREATE OR REPLACE FUNCTION"})," to change a function definition without breaking objects that refer to the function. Also, ",(0,s.jsx)(n.a,{href:"/zh/docs/sql-stmts/alter-function",children:"ALTER FUNCTION"})," can be used to change most of the auxiliary properties of an existing function."]}),"\n",(0,s.jsx)(n.p,{children:"The user that creates the function becomes the owner of the function."}),"\n",(0,s.jsxs)(n.p,{children:["To be able to create a function, you must have ",(0,s.jsx)(n.code,{children:"USAGE"})," privilege on the argument types and the return type."]}),"\n",(0,s.jsxs)(n.p,{children:["For more information about creating functions, refer to the ",(0,s.jsx)(n.a,{href:"https://www.postgresql.org/docs/12/xfunc.html",children:"User Defined Functions"})," section of the PostgreSQL documentation."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Limited Use of VOLATILE and STABLE Functions"})}),"\n",(0,s.jsxs)(n.p,{children:["To prevent data from becoming out-of-sync across the segments in Cloudberry Database, any function classified as ",(0,s.jsx)(n.code,{children:"STABLE"})," or ",(0,s.jsx)(n.code,{children:"VOLATILE"})," cannot be run at the segment level if it contains SQL or modifies the database in any way. For example, functions such as ",(0,s.jsx)(n.code,{children:"random()"})," or ",(0,s.jsx)(n.code,{children:"timeofday()"})," are not allowed to run on distributed data in Cloudberry Database because they could potentially cause inconsistent data between the segment instances."]}),"\n",(0,s.jsxs)(n.p,{children:["To ensure data consistency, ",(0,s.jsx)(n.code,{children:"VOLATILE"})," and ",(0,s.jsx)(n.code,{children:"STABLE"})," functions can safely be used in statements that are evaluated on and run from the coordinator. For example, the following statements are always run on the coordinator (statements without a ",(0,s.jsx)(n.code,{children:"FROM"})," clause):"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"SELECT setval('myseq', 201);\nSELECT foo();\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In cases where a statement has a ",(0,s.jsx)(n.code,{children:"FROM"})," clause containing a distributed table and the function used in the ",(0,s.jsx)(n.code,{children:"FROM"})," clause simply returns a set of rows, execution may be allowed on the segments:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"SELECT * FROM foo();\n"})}),"\n",(0,s.jsxs)(n.p,{children:["One exception to this rule are functions that return a table reference (",(0,s.jsx)(n.code,{children:"rangeFuncs"}),") or functions that use the ",(0,s.jsx)(n.code,{children:"refCursor"})," data type. Note that you cannot return a ",(0,s.jsx)(n.code,{children:"refcursor"})," from any kind of function in Cloudberry Database."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Function Volatility and EXECUTE ON Attributes"})}),"\n",(0,s.jsxs)(n.p,{children:["Volatility attributes (",(0,s.jsx)(n.code,{children:"IMMUTABLE"}),", ",(0,s.jsx)(n.code,{children:"STABLE"}),", ",(0,s.jsx)(n.code,{children:"VOLATILE"}),") and ",(0,s.jsx)(n.code,{children:"EXECUTE ON"})," attributes specify two different aspects of function execution. In general, volatility indicates when the function is run, and ",(0,s.jsx)(n.code,{children:"EXECUTE ON"})," indicates where it is run."]}),"\n",(0,s.jsxs)(n.p,{children:["For example, a function defined with the ",(0,s.jsx)(n.code,{children:"IMMUTABLE"})," attribute can be run at query planning time, while a function with the ",(0,s.jsx)(n.code,{children:"VOLATILE"})," attribute must be run for every row in the query. A function with the ",(0,s.jsx)(n.code,{children:"EXECUTE ON COORDINATOR"})," attribute is run only on the coordinator segment and a function with the ",(0,s.jsx)(n.code,{children:"EXECUTE ON ALL SEGMENTS"})," attribute is run on all primary segment instances (not the coordinator)."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Functions And Replicated Tables"})}),"\n",(0,s.jsxs)(n.p,{children:["A user-defined function that runs only ",(0,s.jsx)(n.code,{children:"SELECT"})," commands on replicated tables can run on segments. Replicated tables, created with the ",(0,s.jsx)(n.code,{children:"DISTRIBUTED REPLICATED"})," clause, store all of their rows on every segment. It is safe for a function to read them on the segments, but updates to replicated tables must run on the coordinator instance."]}),"\n",(0,s.jsx)(n.h2,{id:"parameters",children:"Parameters"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"name"})})}),"\n",(0,s.jsx)(n.p,{children:"The name (optionally schema-qualified) of the function to create."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"argmode"})})}),"\n",(0,s.jsxs)(n.p,{children:["The mode of an argument: either ",(0,s.jsx)(n.code,{children:"IN"}),", ",(0,s.jsx)(n.code,{children:"OUT"}),", ",(0,s.jsx)(n.code,{children:"INOUT"}),", or ",(0,s.jsx)(n.code,{children:"VARIADIC"}),". If omitted, the default is ",(0,s.jsx)(n.code,{children:"IN"}),". Only ",(0,s.jsx)(n.code,{children:"OUT"})," arguments can follow an argument declared as ",(0,s.jsx)(n.code,{children:"VARIADIC"}),". Also, ",(0,s.jsx)(n.code,{children:"OUT"})," and ",(0,s.jsx)(n.code,{children:"INOUT"})," arguments cannot be used together with the ",(0,s.jsx)(n.code,{children:"RETURNS TABLE"})," notation."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"argname"})})}),"\n",(0,s.jsx)(n.p,{children:"The name of an argument. Some languages (currently only SQL and PL/pgSQL) let you use the name in the function body. For other languages the name of an input argument is just extra documentation, so far as the function itself is concerned; but you can use input argument names when calling a function to improve readability. In any case, the name of an output argument is significant, since it defines the column name in the result row type. (If you omit the name for an output argument, the system will choose a default column name.)"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"argtype"})})}),"\n",(0,s.jsx)(n.p,{children:"The data type(s) of the function's arguments (optionally schema-qualified), if any. The argument types may be base, composite, or domain types, or may reference the type of a table column."}),"\n",(0,s.jsxs)(n.p,{children:["Depending on the implementation language it may also be allowed to specify pseudotypes such as ",(0,s.jsx)(n.code,{children:"cstring"}),". Pseudotypes indicate that the actual argument type is either incompletely specified, or outside the set of ordinary SQL data types."]}),"\n",(0,s.jsxs)(n.p,{children:["The type of a column is referenced by writing ",(0,s.jsx)(n.code,{children:"table_name.column_name%TYPE"}),". Using this feature can sometimes help make a function independent of changes to the definition of a table."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"default_expr"})})}),"\n",(0,s.jsxs)(n.p,{children:["An expression to be used as the default value if the parameter is not specified. The expression must be coercible to the argument type of the parameter. Only input (including ",(0,s.jsx)(n.code,{children:"INOUT"}),") parameters can have a default value. Each input parameter in the argument list that follows a parameter with a default value must have a default value as well."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"rettype"})})}),"\n",(0,s.jsxs)(n.p,{children:["The return data type (optionally schema-qualified). The return type can be a base, composite, or domain type, or may reference the type of a table column. Depending on the implementation language it may also be allowed to specify pseudotypes such as ",(0,s.jsx)(n.code,{children:"cstring"}),". If the function is not supposed to return a value, specify ",(0,s.jsx)(n.code,{children:"void"})," as the return type."]}),"\n",(0,s.jsxs)(n.p,{children:["When there are ",(0,s.jsx)(n.code,{children:"OUT"})," or ",(0,s.jsx)(n.code,{children:"INOUT"})," parameters, the ",(0,s.jsx)(n.code,{children:"RETURNS"})," clause may be omitted. If present, it must agree with the result type implied by the output parameters: ",(0,s.jsx)(n.code,{children:"RECORD"})," if there are multiple output parameters, or the same type as the single output parameter."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"SETOF"})," modifier indicates that the function will return a set of items, rather than a single item."]}),"\n",(0,s.jsxs)(n.p,{children:["The type of a column is referenced by writing ",(0,s.jsx)(n.code,{children:"table_name.column_name%TYPE"}),"."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"column_name"})})}),"\n",(0,s.jsxs)(n.p,{children:["The name of an output column in the ",(0,s.jsx)(n.code,{children:"RETURNS TABLE"})," syntax. This is effectively another way of declaring a named ",(0,s.jsx)(n.code,{children:"OUT"})," parameter, except that ",(0,s.jsx)(n.code,{children:"RETURNS TABLE"})," also implies ",(0,s.jsx)(n.code,{children:"RETURNS SETOF"}),"."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"column_type"})})}),"\n",(0,s.jsxs)(n.p,{children:["The data type of an output column in the ",(0,s.jsx)(n.code,{children:"RETURNS TABLE"})," syntax."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"lang_name"})})}),"\n",(0,s.jsxs)(n.p,{children:["The name of the language that the function is implemented in. May be ",(0,s.jsx)(n.code,{children:"SQL"}),", ",(0,s.jsx)(n.code,{children:"C"}),", ",(0,s.jsx)(n.code,{children:"internal"}),", or the name of a user-defined procedural language, e.g. ",(0,s.jsx)(n.code,{children:"plpgsql"}),". Enclosing the name in single quotes is deprecated and requires matching case."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"TRANSFORM { FOR TYPE type_name } [, ... ] }"})})}),"\n",(0,s.jsx)(n.p,{children:"Lists which transforms a call to the function should apply. Transforms convert between SQL types and language-specific data types. Procedural language implementations usually have hardcoded knowledge of the built-in types, so those don't need to be listed here. If a procedural language implementation does not know how to handle a type and no transform is supplied, it will fall back to a default behavior for converting data types, but this depends on the implementation."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"WINDOW"})})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"WINDOW"})," indicates that the function is a window function rather than a plain function. This is currently only useful for functions written in C. The ",(0,s.jsx)(n.code,{children:"WINDOW"})," attribute cannot be changed when replacing an existing function definition."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"IMMUTABLE"})}),(0,s.jsx)("br",{}),"\n",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"STABLE"})}),(0,s.jsx)("br",{}),"\n",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"VOLATILE"})})]}),"\n",(0,s.jsxs)(n.p,{children:["These attributes inform the query optimizer about the behavior of the function. At most one choice may be specified. If none of these appear, ",(0,s.jsx)(n.code,{children:"VOLATILE"})," is the default assumption. Since Cloudberry Database currently has limited use of ",(0,s.jsx)(n.code,{children:"VOLATILE"})," functions, if a function is truly ",(0,s.jsx)(n.code,{children:"IMMUTABLE"}),", you must declare it as so to be able to use it without restrictions."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"IMMUTABLE"})," indicates that the function cannot modify the database and always returns the same result when given the same argument values. It does not do database lookups or otherwise use information not directly present in its argument list. If this option is given, any call of the function with all-constant arguments can be immediately replaced with the function value."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"STABLE"})," indicates that the function cannot modify the database, and that within a single table scan it will consistently return the same result for the same argument values, but that its result could change across SQL statements. This is the appropriate selection for functions whose results depend on database lookups, parameter variables (such as the current time zone), and so on. Also note that the ",(0,s.jsx)(n.code,{children:"current_timestamp()"})," family of functions qualify as stable, since their values do not change within a transaction."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"VOLATILE"})," indicates that the function value can change even within a single table scan, so no optimizations can be made. Relatively few database functions are volatile in this sense; some examples are ",(0,s.jsx)(n.code,{children:"random()"}),", ",(0,s.jsx)(n.code,{children:"timeofday()"}),". But note that any function that has side-effects must be classified volatile, even if its result is quite predictable, to prevent calls from being optimized away; an example is ",(0,s.jsx)(n.code,{children:"setval()"}),"."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"LEAKPROOF"})})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"LEAKPROOF"})," indicates that the function has no side effects. It reveals no information about its arguments other than by its return value. For example, a function that throws an error message for some argument values but not others, or that includes the argument values in any error message, is not leakproof. This affects how the system executes queries against views created with the ",(0,s.jsx)(n.code,{children:"security_barrier"})," option or tables with row level security enabled. The system will enforce conditions from security policies and security barrier views before any user-supplied conditions from the query itself that contain non-leakproof functions, in order to prevent the inadvertent exposure of data. Functions and operators marked as leakproof are assumed to be trustworthy, and may be executed before conditions from security policies and security barrier views. In addition, functions which do not take arguments or which are not passed any arguments from the security barrier view or table do not have to be marked as leakproof to be executed before security conditions. See ",(0,s.jsx)(n.a,{href:"/zh/docs/sql-stmts/create-view",children:"CREATE VIEW"}),". This option can only be set by the superuser."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"CALLED ON NULL INPUT"})}),(0,s.jsx)("br",{}),"\n",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"RETURNS NULL ON NULL INPUT"})}),(0,s.jsx)("br",{}),"\n",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"STRICT"})})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"CALLED ON NULL INPUT"})," (the default) indicates that the function will be called normally when some of its arguments are null. It is then the function author's responsibility to check for null values if necessary and respond appropriately."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"RETURNS NULL ON NULL INPUT"})," or ",(0,s.jsx)(n.code,{children:"STRICT"})," indicates that the function always returns null whenever any of its arguments are null. If this parameter is specified, the function is not run when there are null arguments; instead a null result is assumed automatically."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"[EXTERNAL] SECURITY INVOKER"})}),(0,s.jsx)("br",{}),"\n",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"[EXTERNAL] SECURITY DEFINER"})})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"SECURITY INVOKER"})," (the default) indicates that the function is to be run with the privileges of the user that calls it."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"SECURITY DEFINER"})," specifies that the function is to be run with the privileges of the user that created it."]}),"\n",(0,s.jsxs)(n.p,{children:["The key word ",(0,s.jsx)(n.code,{children:"EXTERNAL"})," is allowed for SQL conformance, but it is optional since, unlike in SQL, this feature applies to all functions not just external ones."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"EXECUTE ON ANY"})}),(0,s.jsx)("br",{}),"\n",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"EXECUTE ON COORDINATOR"})}),(0,s.jsx)("br",{}),"\n",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"EXECUTE ON ALL SEGMENTS"})}),(0,s.jsx)("br",{}),"\n",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"EXECUTE ON INITPLAN"})})]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"EXECUTE ON"})," attributes specify where (coordinator or segment instance) a function runs when it is invoked during the query execution process."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"EXECUTE ON ANY"})," (the default) indicates that the function can be run on the coordinator, or any segment instance, and it returns the same result regardless of where it is run. Cloudberry Database determines where the function runs."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"EXECUTE ON COORDINATOR"})," indicates that the function must run only on the coordinator instance."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"EXECUTE ON ALL SEGMENTS"})," indicates that the function must run on all primary segment instances, but not the coordinator, for each invocation. The overall result of the function is the ",(0,s.jsx)(n.code,{children:"UNION ALL"})," of the results from all segment instances."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"EXECUTE ON INITPLAN"})," indicates that the function contains an SQL command that dispatches queries to the segment instances and requires special processing on the coordinator instance by Cloudberry Database when possible."]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note"})," ",(0,s.jsx)(n.code,{children:"EXECUTE ON INITPLAN"})," is only supported in functions that are used in the ",(0,s.jsx)(n.code,{children:"FROM"})," clause of a ",(0,s.jsx)(n.code,{children:"CREATE TABLE AS"})," or ",(0,s.jsx)(n.code,{children:"INSERT"})," command such as the ",(0,s.jsx)(n.code,{children:"get_data()"})," function in these commands."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE t AS SELECT * FROM get_data();\n\nINSERT INTO t1 SELECT * FROM get_data();\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Cloudberry Database does not support the ",(0,s.jsx)(n.code,{children:"EXECUTE ON INITPLAN"})," attribute in a function that is used in the ",(0,s.jsx)(n.code,{children:"WITH"})," clause of a query, a CTE (common table expression). For example, specifying ",(0,s.jsx)(n.code,{children:"EXECUTE ON INITPLAN"})," in function ",(0,s.jsx)(n.code,{children:"get_data()"})," in this CTE is not supported."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"WITH tbl_a AS (SELECT * FROM get_data() )\n    SELECT * from tbl_a\n    UNION\n    SELECT * FROM tbl_b;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["For information about using ",(0,s.jsx)(n.code,{children:"EXECUTE ON"})," attributes, see ",(0,s.jsx)(n.a,{href:"#notes",children:"Notes"}),"."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"PARALLEL"})})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"PARALLEL UNSAFE"})," indicates that the function can't be executed in parallel mode and the presence of such a function in an SQL statement forces a serial execution plan. This is the default. ",(0,s.jsx)(n.code,{children:"PARALLEL RESTRICTED"})," indicates that the function can be executed in parallel mode, but the execution is restricted to parallel group leader. ",(0,s.jsx)(n.code,{children:"PARALLEL SAFE"})," indicates that the function is safe to run in parallel mode without restriction."]}),"\n",(0,s.jsxs)(n.p,{children:["Functions should be labeled parallel unsafe if they modify any database state, or if they make changes to the transaction such as using sub-transactions, or if they access sequences or attempt to make persistent changes to settings (e.g., ",(0,s.jsx)(n.code,{children:"setval()"}),"). They should be labeled as parallel restricted if they access temporary tables, client connection state, cursors, prepared statements, or miscellaneous backend-local state which the system cannot synchronize in parallel mode (e.g., ",(0,s.jsx)(n.code,{children:"setseed()"})," cannot be executed other than by the group leader because a change made by another process would not be reflected in the leader). In general, if a function is labeled as being safe when it is restricted or unsafe, or if it is labeled as being restricted when it is in fact unsafe, it may throw errors or produce wrong answers when used in a parallel query. C-language functions could in theory exhibit totally undefined behavior if mislabeled, since there is no way for the system to protect itself against arbitrary C code, but in most likely cases the result will be no worse than for any other function. If in doubt, functions should be labeled as ",(0,s.jsx)(n.code,{children:"UNSAFE"}),", which is the default."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"COST execution_cost"})})}),"\n",(0,s.jsxs)(n.p,{children:["A positive number identifying the estimated execution cost for the function, in units of ",(0,s.jsx)(n.a,{href:"https://www.postgresql.org/docs/12/runtime-config-query.html",children:"cpu_operator_cost"}),". If the function returns a set, execution_cost identifies the cost per returned row. If the cost is not specified, C-language and internal functions default to 1 unit, while functions in other languages default to 100 units. Larger values cause the planner to try to avoid evaluating the function more often than necessary."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"ROWS result_rows"})})}),"\n",(0,s.jsx)(n.p,{children:"A positive number giving the estimated number of rows that the planner should expect the function to return. This is only allowed when the function is declared to return a set. The default assumption is 1000 rows."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"SUPPORT support_function"})})}),"\n",(0,s.jsx)(n.p,{children:"The name (optionally schema-qualified) of a planner support function to use for this function. You must be superuser to use this option."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"configuration_parameter"})}),(0,s.jsx)("br",{}),"\n",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"value"})})]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"SET"})," clause applies a value to a session configuration parameter when the function is entered. The configuration parameter is restored to its prior value when the function exits. ",(0,s.jsx)(n.code,{children:"SET FROM CURRENT"})," saves the value of the parameter that is current when ",(0,s.jsx)(n.code,{children:"CREATE FUNCTION"})," is run as the value to be applied when the function is entered."]}),"\n",(0,s.jsxs)(n.p,{children:["If a ",(0,s.jsx)(n.code,{children:"SET"})," clause is attached to a function, then the effects of a ",(0,s.jsx)(n.code,{children:"SET LOCAL"})," command executed inside the function for the same variable are restricted to the function: the configuration parameter's prior value is still restored at function exit. However, an ordinary ",(0,s.jsx)(n.code,{children:"SET"})," command (without ",(0,s.jsx)(n.code,{children:"LOCAL"}),") overrides the ",(0,s.jsx)(n.code,{children:"SET"})," clause, much as it would do for a previous ",(0,s.jsx)(n.code,{children:"SET LOCAL"})," command: the effects of such a command will persist after function exit, unless the current transaction is rolled back."]}),"\n",(0,s.jsxs)(n.p,{children:["See ",(0,s.jsx)(n.a,{href:"/zh/docs/sql-stmts/set",children:"SET"})," for more information about allowed parameter names and values."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"definition"})})}),"\n",(0,s.jsx)(n.p,{children:"A string constant defining the function; the meaning depends on the language. It may be an internal function name, the path to an object file, an SQL command, or text in a procedural language."}),"\n",(0,s.jsxs)(n.p,{children:["It is often helpful to use dollar quoting (refer to ",(0,s.jsx)(n.a,{href:"https://www.postgresql.org/docs/12/sql-syntax-lexical.html#SQL-SYNTAX-DOLLAR-QUOTING",children:"Dollar-Quoted String Constants\n"})," in the PostgreSQL documentation) to write the function definition string, rather than the normal single quote syntax. Without dollar quoting, any single quotes or backslashes in the function definition must be escaped by doubling them."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"obj_file, link_symbol"})})}),"\n",(0,s.jsxs)(n.p,{children:["This form of the ",(0,s.jsx)(n.code,{children:"AS"})," clause is used for dynamically loadable C language functions when the function name in the C language source code is not the same as the name of the SQL function. The string obj_file is the name of the file containing the dynamically loadable object, and is interpreted as for the ",(0,s.jsx)(n.a,{href:"/zh/docs/sql-stmts/load",children:"LOAD"})," command. The string link_symbol is the name of the function in the C language source code. If the link symbol is omitted, it is assumed to be the same as the name of the SQL function being defined. The C names of all functions must be different, so you must give overloaded SQL functions different C names (for example, use the argument types as part of the C names)."]}),"\n",(0,s.jsxs)(n.p,{children:["When repeated ",(0,s.jsx)(n.code,{children:"CREATE FUNCTION"})," calls refer to the same object file, the file is only loaded once per session. To unload and reload the file (perhaps during development), start a new session."]}),"\n",(0,s.jsxs)(n.p,{children:["Locating shared libraries either relative to ",(0,s.jsx)(n.code,{children:"$libdir"})," (which is located at ",(0,s.jsx)(n.code,{children:"$GPHOME/lib"}),") or through the dynamic library path (set by the ",(0,s.jsx)(n.code,{children:"dynamic_library_path"})," server configuration parameter) will simplify version upgrades if the new installation is at a different location."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"describe_function"})})}),"\n",(0,s.jsx)(n.p,{children:"The name of a callback function to run when a query that calls this function is parsed. The callback function returns a tuple descriptor that indicates the result type."}),"\n",(0,s.jsx)(n.h2,{id:"overloading",children:"Overloading"}),"\n",(0,s.jsxs)(n.p,{children:["Cloudberry Database allows function overloading; that is, the same name can be used for several different functions so long as they have distinct input argument types. Whether or not you use it, this capability entails security precautions when calling functions in databases where some users mistrust other users; refer to ",(0,s.jsx)(n.a,{href:"https://www.postgresql.org/docs/12/typeconv-func.html",children:"Functions"})," in the PostgreSQL documentation for more information."]}),"\n",(0,s.jsxs)(n.p,{children:["Two functions are considered the same if they have the same names and input argument types, ignoring any ",(0,s.jsx)(n.code,{children:"OUT"})," parameters. Thus for example these declarations conflict:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"CREATE FUNCTION foo(int) ...\nCREATE FUNCTION foo(int, out text) ...\n"})}),"\n",(0,s.jsx)(n.p,{children:"Functions that have different argument type lists will not be considered to conflict at creation time, but if defaults are provided they might conflict in use. For example, consider:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"CREATE FUNCTION foo(int) ...\nCREATE FUNCTION foo(int, int default 42) ...\n"})}),"\n",(0,s.jsxs)(n.p,{children:["A call ",(0,s.jsx)(n.code,{children:"foo(10)"})," will fail due to the ambiguity about which function should be called."]}),"\n",(0,s.jsx)(n.h2,{id:"notes",children:"Notes"}),"\n",(0,s.jsxs)(n.p,{children:["Any compiled code (shared library files) for custom functions must be placed in the same location on every host in your Cloudberry Database cluster (coordinator and all segments). This location must also be in the ",(0,s.jsx)(n.code,{children:"LD_LIBRARY_PATH"})," so that the server can locate the files. It is recommended that you locate shared libraries either relative to ",(0,s.jsx)(n.code,{children:"$libdir"})," (which is located at ",(0,s.jsx)(n.code,{children:"$GPHOME/lib"}),") or through the dynamic library path (set by the ",(0,s.jsx)(n.code,{children:"dynamic_library_path"})," server configuration parameter) on all coordinator segment instances in the Cloudberry Database cluster."]}),"\n",(0,s.jsxs)(n.p,{children:["The full SQL type syntax is allowed for input arguments and return value. However, parenthesized type modifiers (e.g., the precision field for type ",(0,s.jsx)(n.code,{children:"numeric"}),") are discarded by ",(0,s.jsx)(n.code,{children:"CREATE FUNCTION"}),". Thus for example ",(0,s.jsx)(n.code,{children:"CREATE FUNCTION foo (varchar(10)) ..."})," is exactly the same as ",(0,s.jsx)(n.code,{children:"CREATE FUNCTION foo (varchar) ..."}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["When replacing an existing function with ",(0,s.jsx)(n.code,{children:"CREATE OR REPLACE FUNCTION"}),", there are restrictions on changing parameter names. You cannot change the name already assigned to any input parameter (although you can add names to parameters that had none before). If there is more than one output parameter, you cannot change the names of the output parameters, because that would change the column names of the anonymous composite type that describes the function's result. These restrictions are made to ensure that existing calls of the function do not stop working when it is replaced."]}),"\n",(0,s.jsxs)(n.p,{children:["If a function is declared ",(0,s.jsx)(n.code,{children:"STRICT"})," with a ",(0,s.jsx)(n.code,{children:"VARIADIC"})," argument, the strictness check tests that the variadic array as a whole is non-null. The function will still be called if the array has null elements."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Using Functions with Queries on Distributed Data"})}),"\n",(0,s.jsxs)(n.p,{children:["In some cases, Cloudberry Database does not support using functions in a query where the data in a table specified in the ",(0,s.jsx)(n.code,{children:"FROM"})," clause is distributed over Cloudberry Database segments. As an example, this SQL query contains the function ",(0,s.jsx)(n.code,{children:"func()"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"SELECT func(a) FROM table1;\n"})}),"\n",(0,s.jsx)(n.p,{children:"The function is not supported for use in the query if all of the following conditions are met:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The data of table ",(0,s.jsx)(n.code,{children:"table1"})," is distributed over Cloudberry Database segments."]}),"\n",(0,s.jsxs)(n.li,{children:["The function ",(0,s.jsx)(n.code,{children:"func()"})," reads or modifies data from distributed tables."]}),"\n",(0,s.jsxs)(n.li,{children:["The function ",(0,s.jsx)(n.code,{children:"func()"})," returns more than one row or takes an argument (",(0,s.jsx)(n.code,{children:"a"}),") that comes from ",(0,s.jsx)(n.code,{children:"table1"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"If any of the conditions are not met, the function is supported. Specifically, the function is supported if any of the following conditions apply:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The function ",(0,s.jsx)(n.code,{children:"func()"})," does not access data from distributed tables, or accesses data that is only on the Cloudberry Database coordinator."]}),"\n",(0,s.jsxs)(n.li,{children:["The table ",(0,s.jsx)(n.code,{children:"table1"})," is a coordinator only table."]}),"\n",(0,s.jsxs)(n.li,{children:["The function ",(0,s.jsx)(n.code,{children:"func()"})," returns only one row and only takes input arguments that are constant values. The function is supported if it can be changed to require no input arguments."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Using EXECUTE ON attributes"})}),"\n",(0,s.jsxs)(n.p,{children:["Most functions that run queries to access tables can only run on the coordinator. However, functions that run only ",(0,s.jsx)(n.code,{children:"SELECT"})," queries on replicated tables can run on segments. If the function accesses a hash-distributed table or a randomly distributed table, the function should be defined with the ",(0,s.jsx)(n.code,{children:"EXECUTE ON COORDINATOR"})," attribute. Otherwise, the function might return incorrect results when the function is used in a complicated query. Without the attribute, planner optimization might determine it would be beneficial to push the function invocation to segment instances."]}),"\n",(0,s.jsxs)(n.p,{children:["These are limitations for functions defined with the ",(0,s.jsx)(n.code,{children:"EXECUTE ON COORDINATOR"})," or ",(0,s.jsx)(n.code,{children:"EXECUTE ON ALL SEGMENTS"})," attribute:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The function must be a set-returning function."}),"\n",(0,s.jsxs)(n.li,{children:["The function cannot be in the ",(0,s.jsx)(n.code,{children:"FROM"})," clause of a query."]}),"\n",(0,s.jsxs)(n.li,{children:["The function cannot be in the ",(0,s.jsx)(n.code,{children:"SELECT"})," list of a query with a ",(0,s.jsx)(n.code,{children:"FROM"})," clause."]}),"\n",(0,s.jsx)(n.li,{children:"A query that includes the function falls back from GPORCA to the Postgres Planner."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The attribute ",(0,s.jsx)(n.code,{children:"EXECUTE ON INITPLAN"})," indicates that the function contains an SQL command that dispatches queries to the segment instances and requires special processing on the coordinator instance by Cloudberry Database. When possible, Cloudberry Database handles the function on the coordinator instance in the following manner."]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"First, Cloudberry Database runs the function as part of an InitPlan node on the coordinator instance and holds the function output temporarily."}),"\n",(0,s.jsx)(n.li,{children:"Then, in the MainPlan of the query plan, the function is called in an EntryDB (a special query executor (QE) that runs on the coordinator instance) and Cloudberry Database returns the data that was captured when the function was run as part of the InitPlan node. The function is not run in the MainPlan."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["This simple example uses the function ",(0,s.jsx)(n.code,{children:"get_data()"})," in a CTAS command to create a table using data from the table ",(0,s.jsx)(n.code,{children:"country"}),". The function contains a ",(0,s.jsx)(n.code,{children:"SELECT"})," command that retrieves data from the table ",(0,s.jsx)(n.code,{children:"country"})," and uses the ",(0,s.jsx)(n.code,{children:"EXECUTE ON INITPLAN"})," attribute."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE country( \n  c_id integer, c_name text, region int) \n  DISTRIBUTED RANDOMLY;\n\nINSERT INTO country VALUES (11,'INDIA', 1 ), (22,'CANADA', 2), (33,'USA', 3);\n\nCREATE OR REPLACE FUNCTION get_data()\n  RETURNS TABLE (\n   c_id integer, c_name text\n   )\nAS $$\n  SELECT\n    c.c_id, c.c_name\n  FROM\n    country c;\n$$\nLANGUAGE SQL EXECUTE ON INITPLAN;\n\nCREATE TABLE t AS SELECT * FROM get_data() DISTRIBUTED RANDOMLY;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["If you view the query plan of the CTAS command with ",(0,s.jsx)(n.code,{children:"EXPLAIN ANALYZE VERBOSE"}),", the plan shows that the function is run as part of an InitPlan node, and one of the listed slices is labeled as ",(0,s.jsx)(n.code,{children:"entry db"}),". The query plan of a simple CTAS command without the function does not have an InitPlan node or an ",(0,s.jsx)(n.code,{children:"entry db"})," slice."]}),"\n",(0,s.jsxs)(n.p,{children:["If the function did not contain the ",(0,s.jsx)(n.code,{children:"EXECUTE ON INITPLAN"})," attribute, the CTAS command returns the error ",(0,s.jsx)(n.code,{children:"function cannot execute on a QE slice"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["When a function uses the ",(0,s.jsx)(n.code,{children:"EXECUTE ON INITPLAN"})," attribute, a command that uses the function such as ",(0,s.jsx)(n.code,{children:"CREATE TABLE t AS SELECT * FROM get_data()"})," gathers the results of the function onto the coordinator segment and then redistributes the results to segment instances when inserting the data. If the function returns a large amount of data, the coordinator might become a bottleneck when gathering and redistributing data. Performance might improve if you rewrite the function to run the CTAS command in the user defined function and use the table name as an input parameter. In this example, the function runs a CTAS command and does not require the ",(0,s.jsx)(n.code,{children:"EXECUTE ON INITPLAN"})," attribute. Running the ",(0,s.jsx)(n.code,{children:"SELECT"})," command creates the table ",(0,s.jsx)(n.code,{children:"t1"})," using the function that runs the CTAS command."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"CREATE OR REPLACE FUNCTION my_ctas(_tbl text) RETURNS VOID AS\n$$\nBEGIN\n  EXECUTE format('CREATE TABLE %s AS SELECT c.c_id, c.c_name FROM country c DISTRIBUTED RANDOMLY', _tbl);\nEND\n$$\nLANGUAGE plpgsql;\n\nSELECT my_ctas('t1');\n"})}),"\n",(0,s.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,s.jsx)(n.p,{children:"Add two integers using a SQL function:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"CREATE FUNCTION add(integer, integer) RETURNS integer\n    AS 'select $1 + $2;'\n    LANGUAGE SQL\n    IMMUTABLE\n    RETURNS NULL ON NULL INPUT;\n"})}),"\n",(0,s.jsx)(n.p,{children:"Increment an integer, making use of an argument name, in PL/pgSQL:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"CREATE OR REPLACE FUNCTION increment(i integer) RETURNS \ninteger AS $$\n        BEGIN\n                RETURN i + 1;\n        END;\n$$ LANGUAGE plpgsql;\n"})}),"\n",(0,s.jsx)(n.p,{children:"Return a record containing multiple output parameters:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"CREATE FUNCTION dup(in int, out f1 int, out f2 text)\n    AS $$ SELECT $1, CAST($1 AS text) || ' is text' $$\n    LANGUAGE SQL;\n\nSELECT * FROM dup(42);\n"})}),"\n",(0,s.jsx)(n.p,{children:"You can do the same thing more verbosely with an explicitly named composite type:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"CREATE TYPE dup_result AS (f1 int, f2 text);\n\nCREATE FUNCTION dup(int) RETURNS dup_result\n    AS $$ SELECT $1, CAST($1 AS text) || ' is text' $$\n    LANGUAGE SQL;\n\nSELECT * FROM dup(42);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Another way to return multiple columns is to use a ",(0,s.jsx)(n.code,{children:"TABLE"})," function:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"CREATE FUNCTION dup(int) RETURNS TABLE(f1 int, f2 text)\n    AS $$ SELECT $1, CAST($1 AS text) || ' is text' $$\n    LANGUAGE SQL;\n\nSELECT * FROM dup(42);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["However, a ",(0,s.jsx)(n.code,{children:"TABLE"})," function is different from the preceding examples, because it actually returns a set of records, not just one record."]}),"\n",(0,s.jsx)(n.p,{children:"Increase the default segment host memory per query for a PL/pgSQL function:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"CREATE OR REPLACE FUNCTION function_with_query() RETURNS \nSETOF text AS $$\n        BEGIN\n                RETURN QUERY\n                EXPLAIN ANALYZE SELECT * FROM large_table;\n        END;\n$$ LANGUAGE plpgsql\nSET statement_mem='256MB';\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Use polymorphic types to return an ",(0,s.jsx)(n.code,{children:"ENUM"})," array:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"CREATE TYPE rainbow AS ENUM('red','orange','yellow','green','blue','indigo','violet');\nCREATE FUNCTION return_enum_as_array( anyenum, anyelement, anyelement ) \n    RETURNS TABLE (ae anyenum, aa anyarray) AS $$\n    SELECT $1, array[$2, $3] \n$$ LANGUAGE SQL STABLE;\n\nSELECT * FROM return_enum_as_array('red'::rainbow, 'green'::rainbow, 'blue'::rainbow);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This function is defined with the ",(0,s.jsx)(n.code,{children:"EXECUTE ON ALL SEGMENTS"})," to run on all primary segment instances. The ",(0,s.jsx)(n.code,{children:"SELECT"})," command runs the function that returns the time it was run on each segment instance."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"CREATE FUNCTION run_on_segs (text) returns setof text as $$\n  begin \n    return next ($1 || ' - ' || now()::text ); \n  end;\n $$ language plpgsql VOLATILE EXECUTE ON ALL SEGMENTS;\n\nSELECT run_on_segs('my test');\n"})}),"\n",(0,s.jsx)(n.p,{children:"This function looks up a part name in the parts table. The parts table is replicated, so the function can run on the coordinator or on the primary segments."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"CREATE OR REPLACE FUNCTION get_part_name(partno int) RETURNS text AS\n$$\nDECLARE\n   result text := ' ';\nBEGIN\n    SELECT part_name INTO result FROM parts WHERE part_id = partno;\n    RETURN result;\nEND;\n$$ LANGUAGE plpgsql;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["If you run ",(0,s.jsx)(n.code,{children:"SELECT get_part_name(100);"})," at the coordinator the function runs on the coordinator. (The coordinator instance directs the query to a single primary segment.) If orders is a distributed table and you run the following query, the ",(0,s.jsx)(n.code,{children:"get_part_name()"})," function runs on the primary segments."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"`SELECT order_id, get_part_name(orders.part_no) FROM orders;`\n"})}),"\n",(0,s.jsx)(n.h2,{id:"writing-security-definer-functions-safely",children:"Writing security definer functions safely"}),"\n",(0,s.jsxs)(n.p,{children:["Because a ",(0,s.jsx)(n.code,{children:"SECURITY DEFINER"})," function is executed with the privileges of the user that created it, care is needed to ensure that the function cannot be misused. For security, ",(0,s.jsx)(n.code,{children:"search_path"})," should be set to exclude any schemas writable by untrusted users. This prevents malicious users from creating objects that mask objects used by the function. Particularly important in this regard is the temporary-table schema, which is searched first by default, and is normally writable by anyone. A secure arrangement can be had by forcing the temporary schema to be searched last. To do this, write ",(0,s.jsx)(n.code,{children:"pg_temp"})," as the last entry in ",(0,s.jsx)(n.code,{children:"search_path"}),". This function illustrates safe usage:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"CREATE FUNCTION check_password(uname TEXT, pass TEXT)\nRETURNS BOOLEAN AS $$\nDECLARE passed BOOLEAN;\nBEGIN\n        SELECT  (pwd = $2) INTO passed\n        FROM    pwds\n        WHERE   username = $1;\n\n        RETURN passed;\nEND;\n$$  LANGUAGE plpgsql\n    SECURITY DEFINER\n    -- Set a secure search_path: trusted schema(s), then 'pg_temp'.\n    SET search_path = admin, pg_temp;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"SET"})," option was not available in earlier versions of Cloudberry Database, and so older functions may contain rather complicated logic to save, set, and restore ",(0,s.jsx)(n.code,{children:"search_path"}),". The ",(0,s.jsx)(n.code,{children:"SET"})," option is far easier to use for this purpose."]}),"\n",(0,s.jsxs)(n.p,{children:["Another point to keep in mind is that by default, execute privilege is granted to ",(0,s.jsx)(n.code,{children:"PUBLIC"})," for newly created functions (see ",(0,s.jsx)(n.a,{href:"/zh/docs/sql-stmts/grant",children:"GRANT"})," for more information). Frequently you will wish to restrict use of a security definer function to only some users. To do that, you must revoke the default ",(0,s.jsx)(n.code,{children:"PUBLIC"})," privileges and then grant ",(0,s.jsx)(n.code,{children:"EXECUTE"})," privilege selectively. To avoid having a window where the new function is accessible to all, create it and set the privileges within a single transaction. For example:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"BEGIN;\nCREATE FUNCTION check_password(uname TEXT, pass TEXT) ... SECURITY DEFINER;\nREVOKE ALL ON FUNCTION check_password(uname TEXT, pass TEXT) FROM PUBLIC;\nGRANT EXECUTE ON FUNCTION check_password(uname TEXT, pass TEXT) TO admins;\nCOMMIT;\n"})}),"\n",(0,s.jsx)(n.h2,{id:"compatibility",children:"Compatibility"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"CREATE FUNCTION"})," is defined in SQL:1999 and later. The Cloudberry Database version is similar but not fully compatible. The attributes are not portable, neither are the different available languages."]}),"\n",(0,s.jsx)(n.p,{children:"For compatibility with some other database systems, argmode can be written either before or after argname. But only the first way is standard-compliant."}),"\n",(0,s.jsxs)(n.p,{children:["For parameter defaults, the SQL standard specifies only the syntax with the ",(0,s.jsx)(n.code,{children:"DEFAULT"})," key word. The syntax with ",(0,s.jsx)(n.code,{children:"="})," is used in T-SQL and Firebird."]}),"\n",(0,s.jsx)(n.h2,{id:"see-also",children:"See also"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"/zh/docs/sql-stmts/alter-function",children:"ALTER FUNCTION"}),", ",(0,s.jsx)(n.a,{href:"/zh/docs/sql-stmts/drop-function",children:"DROP FUNCTION"}),", ",(0,s.jsx)(n.a,{href:"/zh/docs/sql-stmts/grant",children:"GRANT"}),", ",(0,s.jsx)(n.a,{href:"/zh/docs/sql-stmts/load",children:"LOAD"}),", ",(0,s.jsx)(n.a,{href:"/zh/docs/sql-stmts/revoke",children:"REVOKE"}),", createlang"]})]})}function h(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},11151:(e,n,t)=>{t.d(n,{Z:()=>o,a:()=>r});var s=t(67294);const i={},a=s.createContext(i);function r(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);