"use strict";(self.webpackChunkApache_Cloudberry_Incubating_website=self.webpackChunkApache_Cloudberry_Incubating_website||[]).push([[5683],{95026:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>c});var i=t(85893),a=t(11151);const s={title:"ALTER TABLE"},r="ALTER TABLE",o={id:"sql-stmts/alter-table",title:"ALTER TABLE",description:"Changes the definition of a table.",source:"@site/docs/sql-stmts/alter-table.md",sourceDirName:"sql-stmts",slug:"/sql-stmts/alter-table",permalink:"/zh/docs/sql-stmts/alter-table",draft:!1,unlisted:!1,editUrl:"https://github.com/apache/cloudberry-site/edit/main/docs/sql-stmts/alter-table.md",tags:[],version:"current",lastUpdatedBy:"Ed Espino",lastUpdatedAt:1732764009,formattedLastUpdatedAt:"2024\u5e7411\u670828\u65e5",frontMatter:{title:"ALTER TABLE"},sidebar:"docsbars",previous:{title:"ALTER STATISTICS",permalink:"/zh/docs/sql-stmts/alter-statistics"},next:{title:"ALTER TABLESPACE",permalink:"/zh/docs/sql-stmts/alter-tablespace"}},l={},c=[{value:"Synopsis",id:"synopsis",level:2},{value:"Description",id:"description",level:2},{value:"Parameters",id:"parameters",level:2},{value:"Classic partitioning syntax parameters",id:"classic-partitioning-syntax-parameters",level:3},{value:"Notes",id:"notes",level:2},{value:"Examples",id:"examples",level:2},{value:"Modern syntax partioning examples",id:"modern-syntax-partioning-examples",level:3},{value:"Classic syntax partioning examples",id:"classic-syntax-partioning-examples",level:3},{value:"Compatibility",id:"compatibility",level:2},{value:"See also",id:"see-also",level:2}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"alter-table",children:"ALTER TABLE"}),"\n",(0,i.jsx)(n.p,{children:"Changes the definition of a table."}),"\n",(0,i.jsx)(n.h2,{id:"synopsis",children:"Synopsis"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"ALTER TABLE [IF EXISTS] [ONLY] <name> [ * ]\n    <action> [, ... ]\n\nALTER TABLE [IF EXISTS] [ONLY] <name> [ * ]\n    RENAME [COLUMN] <column_name> TO <new_column_name>\n\nALTER TABLE [IF EXISTS] [ ONLY ] <name> [ * ]\n    RENAME CONSTRAINT <constraint_name> TO <new_constraint_name>\n\nALTER TABLE [IF EXISTS] <name> \n    RENAME TO <new_name>\n\nALTER TABLE [IF EXISTS] <name> \n    SET SCHEMA <new_schema>\n\nALTER TABLE ALL IN TABLESPACE <name> [ OWNED BY <role_name> [, ... ] ]\n    SET TABLESPACE <new_tablespace> [ NOWAIT ]\n\nALTER TABLE [ IF EXISTS ] <name>\n    ATTACH PARTITION <partition_name> { FOR VALUES <partition_bound_spec> | DEFAULT }\n\nALTER TABLE [ IF EXISTS ] <name>\n    DETACH PARTITION <partition_name>\n\nALTER TABLE [IF EXISTS] [ONLY] <name> SET\n   [ WITH (reorganize={ true | false }) ]\n\xa0\xa0\xa0 \xa0DISTRIBUTED BY ({<column_name> [<opclass>]} [, ... ] )\n\xa0\xa0\xa0| DISTRIBUTED RANDOMLY\n   | DISTRIBUTED REPLICATED\n\n-- where <action> is one of:\n                        \n \xa0ADD [COLUMN] [IF NOT EXISTS] <column_name> <data_type> [ COLLATE <collation> ] [<column_constraint> [ ... ]]\n      [ ENCODING ( <storage_directive> [,...] ) ]\n\xa0\xa0DROP [COLUMN] [IF EXISTS] <column_name> [RESTRICT | CASCADE]\n\xa0\xa0ALTER [COLUMN] <column_name> [ SET DATA ] TYPE <data_type> [COLLATE <collation>] [USING <expression>]\n\xa0\xa0ALTER [COLUMN] <column_name> SET DEFAULT <expression>\n\xa0\xa0ALTER [COLUMN] <column_name> DROP DEFAULT\n\xa0\xa0ALTER [COLUMN] <column_name> { SET | DROP } NOT NULL\n  ALTER [COLUMN] <column_name> ADD GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY [ ( <sequence_options> ) ]\n  ALTER [COLUMN] <column_name> { SET GENERATED { ALWAYS | BY DEFAULT } \n       | SET <sequence_option>\n       | RESTART [ [ WITH ] <restart> ] } [...]\n  ALTER [COLUMN] <column_name> DROP IDENTITY [ IF EXISTS ]\n\xa0\xa0ALTER [COLUMN] <column_name> SET STATISTICS <integer>\n  ALTER [COLUMN] <column_name> SET ( <attribute_option> = <value> [, ... ] )\n  ALTER [COLUMN] <column_name> RESET ( <attribute_option> [, ... ] )\n  ALTER [COLUMN] <column_name> SET STORAGE { PLAIN | EXTERNAL | EXTENDED | MAIN }\n  ALTER [COLUMN] <column_name> SET ENCODING ( storage_directive> [, ...] )\n  ADD <table_constraint> [NOT VALID]\n  ADD <table_constraint_using_index>\n  ALTER CONSTRAINT <constraint_name> [ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]\n  VALIDATE CONSTRAINT <constraint_name>\n\xa0\xa0DROP CONSTRAINT [IF EXISTS] <constraint_name> [RESTRICT | CASCADE]\n  DISABLE ROW LEVEL SECURITY\n  ENABLE ROW LEVEL SECURITY\n  FORCE ROW LEVEL SECURITY\n  NO FORCE ROW LEVEL SECURITY\n\xa0\xa0CLUSTER ON <index_name>\n  REPACK BY COLUMNS (<colum_name_1> [ASC|DESC], <column_name_2> [ASC|DESC], ...)\n\xa0\xa0SET WITHOUT CLUSTER\n  SET WITHOUT OIDS\n\xa0\xa0SET TABLESPACE <new_tablespace>\n  SET { LOGGED | UNLOGGED }\n\xa0\xa0SET ( <storage_parameter> [= <value>] [, ...])\n  SET WITH (<set_with_parameter> = <value> [, ...])\n  SET ACCESS METHOD <access_method>  [WITH ( <storage_parameter> = <value>, [, ...] )]\n\xa0\xa0RESET (<storage_parameter> [, ... ])\n\xa0\xa0INHERIT <parent_table>\n\xa0\xa0NO INHERIT <parent_table>\n  OF <type_name>\n  NOT OF\n\xa0\xa0OWNER TO { <new_owner> | CURRENT_USER | SESSION_USER }\n\nand <partition_bound_spec> is:\n\n  IN ( <partition_bound_expr> [, ...] ) |\n  FROM ( { <partition_bound_expr> | MINVALUE | MAXVALUE } [, ...] )\n    TO ( { <partition_bound_expr> | MINVALUE | MAXVALUE } [, ...] ) |\n  WITH ( MODULUS <numeric_literal>, REMAINDER <numeric_literal> )\n\n-- and <column_constraint> is:\n\n  [ CONSTRAINT <constraint_name>]\n  { NOT NULL\n    | NULL\n\xa0\xa0  | CHECK  ( <expression> )\xa0[ NO INHERIT ]\n    | DEFAULT <default_expr>\n    | GENERATED ALWAYS AS ( <generation_expr> ) STORED\n    | GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY [ ( <sequence_options> ) ]\n \xa0  | UNIQUE <index_parameters>\n\xa0\xa0  | PRIMARY KEY <index_parameters>\n\xa0\xa0  | REFERENCES <reftable> [ ( refcolumn ) ] [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ]\n\xa0\xa0      [ ON DELETE <referential_action> ] [ ON UPDATE <referential_action> ] }\n  [ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]\n\n-- and <table_constraint> is:\n\n  [ CONSTRAINT <constraint_name> ]\n  { CHECK ( <expression> ) [ NO INHERIT ]\n    | UNIQUE ( <column_name> [, ... ] ) <index_parameters>\n    | PRIMARY KEY ( <column_name> [, ... ] ) <index_parameters>\n    | EXCLUDE [ USING <index_method> ] ( <exclude_element> WITH <operator> [, ... ] )\n        <index_parameters> [ WHERE ( <predicate> ) ]\n    | FOREIGN KEY ( <column_name> [, ... ] ) REFERENCES <reftable> [ ( <refcolumn> [, ... ] ) ]\n        [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ] [ ON DELETE <referential_action> ] [ ON UPDATE <referential_action> ] }\n  [ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]\n\n-- and <table_constraint_using_index> is:\n\n  [ CONSTRAINT <constraint_name> ]\n  { UNIQUE | PRIMARY KEY } USING INDEX <index_name>\n  [ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]\n\n-- and <index_parameters> in UNIQUE, PRIMARY KEY, and EXCLUDE constraints are:\n\n  [ INCLUDE ( <column_name> [, ... ] ) ]\n  [ WITH ( <storage_parameter> [=<value>] [, ... ] ) ]\n  [ USING INDEX TABLESPACE <tablespace_name> ]\n\n-- and <exclude_element> in an EXCLUDE constraint is:\n\n  { <column_name> | ( <expression> ) } [ <opclass> ] [ ASC | DESC ]\n     [ NULLS { FIRST | LAST }\n\n-- and <set_with_parameter> is:\n\n   reorganize={ true | false } |\n   orientation={COLUMN|ROW}\n   appendoptimized={ true | false } [, <storage_parameter> [, ...]]\n"})}),"\n",(0,i.jsx)(n.p,{children:"Classic partitioning syntax elements include:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"ALTER TABLE <name>\n\xa0\xa0\xa0[ ALTER PARTITION { <partition_name> | FOR (<value>) } [...] ] <partition_action>\n\n-- where <partition_action> is one of:\n\n\xa0\xa0ALTER DEFAULT PARTITION\n\xa0\xa0DROP DEFAULT PARTITION [IF EXISTS]\n\xa0\xa0DROP PARTITION [IF EXISTS] { <partition_name> | \n\xa0\xa0\xa0\xa0\xa0\xa0FOR (<value>) } [CASCADE]\n\xa0\xa0TRUNCATE DEFAULT PARTITION\n\xa0\xa0TRUNCATE PARTITION { <partition_name> | FOR (<value>) }\n\xa0\xa0RENAME DEFAULT PARTITION TO <new_partition_name>\n\xa0\xa0RENAME PARTITION { <partition_name> | FOR (<value>) } TO <new_partition_name>\n\xa0\xa0ADD DEFAULT PARTITION <name> [ ( <subpartition_spec> ) ]\n\xa0 ADD PARTITION [<partition_name>] <partition_element>\n\xa0\xa0\xa0\xa0\xa0[ ( <subpartition_spec> ) ]\n\xa0\xa0EXCHANGE PARTITION { <partition_name> | FOR (<value>) } WITH TABLE <table_name>\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0[ WITH | WITHOUT VALIDATION ]\n\xa0\xa0EXCHANGE DEFAULT PARTITION WITH TABLE <table_name>\n\xa0\xa0\xa0[ WITH | WITHOUT VALIDATION ]\n\xa0\xa0SET SUBPARTITION TEMPLATE (<subpartition_spec>)\n\xa0\xa0SPLIT DEFAULT PARTITION\n\xa0\xa0\xa0\xa0{ \xa0AT (<list_value>)\n\xa0\xa0\xa0\xa0\xa0| START([<datatype>] <range_value>) [INCLUSIVE | EXCLUSIVE] \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0END([<datatype>] <range_value>) [INCLUSIVE | EXCLUSIVE] }\n\xa0\xa0\xa0\xa0[ INTO ( PARTITION <new_partition_name>, \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 PARTITION <default_partition_name> ) ]\n\xa0\xa0SPLIT PARTITION { <partition_name> | FOR (<value>) } AT (<value>) \n\xa0\xa0\xa0\xa0[ INTO (PARTITION <partition_name>, PARTITION <partition_name>)]\xa0\xa0\n\n-- and <partition_element> is:\n\n\xa0\xa0\xa0\xa0VALUES (<list_value> [,...] )\n\xa0\xa0| START ([<datatype>] '<start_value>') [INCLUSIVE | EXCLUSIVE]\n\xa0\xa0\xa0\xa0\xa0[ END ([<datatype>] '<end_value>') [INCLUSIVE | EXCLUSIVE] ]\n\xa0\xa0| END ([<datatype>] '<end_value>') [INCLUSIVE | EXCLUSIVE]\n[ WITH ( <storage_parameter> = value> [ , ... ] ) ]\n[ TABLESPACE <tablespace> ]\n\nand <subpartition_spec> is:\n\n<subpartition_element> [, ...]\n\n-- and <subpartition_element> is:\n\n\xa0\xa0\xa0DEFAULT SUBPARTITION <subpartition_name>\n\xa0\xa0| [SUBPARTITION <subpartition_name>] VALUES (<list_value> [,...] )\n\xa0\xa0| [SUBPARTITION <subpartition_name>] \n\xa0\xa0\xa0\xa0\xa0START ([<datatype>] '<start_value>') [INCLUSIVE | EXCLUSIVE]\n\xa0\xa0\xa0\xa0\xa0[ END ([<datatype>] '<end_value>') [INCLUSIVE | EXCLUSIVE] ]\n\xa0\xa0\xa0\xa0\xa0[ EVERY ( [<number | datatype>] '<interval_value>') ]\n\xa0\xa0| [SUBPARTITION <subpartition_name>] \n\xa0\xa0\xa0\xa0\xa0END ([<datatype>] '<end_value>') [INCLUSIVE | EXCLUSIVE]\n\xa0\xa0\xa0\xa0\xa0[ EVERY ( [<number | datatype>] '<interval_value>') ]\n[ WITH ( <storage_parameter>=<value> [, ... ] ) ]\n[ TABLESPACE <tablespace> ]\n"})}),"\n",(0,i.jsx)(n.h2,{id:"description",children:"Description"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"ALTER TABLE"})," changes the definition of an existing table. There are several subforms described below. Note that the lock level required may differ for each subform. An ",(0,i.jsx)(n.code,{children:"ACCESS EXCLUSIVE"})," lock is acquired unless explicitly noted. When multiple subcommands are provided, Cloudberry Database acquires the strictest lock required by any subcommand."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"ADD COLUMN [ IF NOT EXISTS ]"})})}),"\n",(0,i.jsxs)(n.p,{children:["Adds a new column to the table, using the same syntax as ",(0,i.jsx)(n.a,{href:"/zh/docs/sql-stmts/create-table",children:"CREATE TABLE"}),". If ",(0,i.jsx)(n.code,{children:"IF NOT EXISTS"})," is specified and a column already exists with this name, no error is thrown."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"DROP COLUMN [ IF EXISTS ]"})})}),"\n",(0,i.jsxs)(n.p,{children:["Drops a column from a table. Note that if you drop table columns that are being used as the Cloudberry Database distribution key, the distribution policy for the table will be changed to ",(0,i.jsx)(n.code,{children:"DISTRIBUTED RANDOMLY"}),". Indexes and table constraints involving the column are automatically dropped as well. Multivariate statistics referencing the dropped column will also be removed if the removal of the column would cause the statistics to contain data for only a single column. You need to specify ",(0,i.jsx)(n.code,{children:"CASCADE"})," if anything outside of the table depends on the column, such as views. If ",(0,i.jsx)(n.code,{children:"IF EXISTS"})," is specified and the column does not exist, no error is thrown; Cloudberry Database issues a notice instead."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"SET DATA TYPE"})})}),"\n",(0,i.jsxs)(n.p,{children:["This form changes the data type of a column of a table. Note that you cannot alter column data types that are being used as distribution or partitioning keys. Indexes and simple table constraints involving the column will be automatically converted to use the new column type by reparsing the originally supplied expression. The optional ",(0,i.jsx)(n.code,{children:"COLLATE"})," clause specifies a collation for the new column; if omitted, the collation is the default for the new column type. The optional ",(0,i.jsx)(n.code,{children:"USING"})," clause specifies how to compute the new column value from the old. If omitted, the default conversion is the same as an assignment cast from old data type to new. A ",(0,i.jsx)(n.code,{children:"USING"})," clause must be provided if there is no implicit or assignment cast from old to new type."]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Note"})," The Cloudberry Query Optimizer (GPORCA) supports collation only when all columns in the query use the same collation. If columns in the query use different collations, then Cloudberry Database uses the Postgres Planner."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Changing a column data type may or may not require a table rewrite. For information about table rewrites performed by ",(0,i.jsx)(n.code,{children:"ALTER TABLE"}),", see ",(0,i.jsx)(n.a,{href:"#notes",children:"Notes"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"SET DEFAULT"})}),(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"DROP DEFAULT"})})]}),"\n",(0,i.jsxs)(n.p,{children:["Sets or removes the default value for a column. Default values apply only in subsequent ",(0,i.jsx)(n.code,{children:"INSERT"})," or ",(0,i.jsx)(n.code,{children:"UPDATE"})," commands; they do not cause rows already in the table to change."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"SET NOT NULL"})}),(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"DROP NOT NULL"})})]}),"\n",(0,i.jsx)(n.p,{children:"Changes whether a column is marked to allow null values or to reject null values."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"SET NOT NULL"})," may only be applied to a column provided none of the records in the table contain a ",(0,i.jsx)(n.code,{children:"NULL"})," value for the column. This is typically checked during the ",(0,i.jsx)(n.code,{children:"ALTER TABLE"})," by scanning the entire table; however, if a valid ",(0,i.jsx)(n.code,{children:"CHECK"})," constraint is found which proves no ",(0,i.jsx)(n.code,{children:"NULL"})," can exist, then Cloudberry Database skips the table scan."]}),"\n",(0,i.jsxs)(n.p,{children:["If this table is a partition, you cannot ",(0,i.jsx)(n.code,{children:"DROP NOT NULL"})," on a column if it is marked ",(0,i.jsx)(n.code,{children:"NOT NULL"})," in the parent table. To drop the ",(0,i.jsx)(n.code,{children:"NOT NULL"})," constraint from all the partitions, perform ",(0,i.jsx)(n.code,{children:"DROP NOT NULL"})," on the parent table. Even if there is no ",(0,i.jsx)(n.code,{children:"NOT NULL"})," constraint on the parent, such a constraint can still be added to individual partitions, if desired; that is, the children can disallow nulls even if the parent allows them, but not the other way around."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"ADD GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY"})}),(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"SET GENERATED { ALWAYS | BY DEFAULT }"})}),(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"DROP IDENTITY [ IF EXISTS ]"})})]}),"\n",(0,i.jsxs)(n.p,{children:["These forms change whether a column is an identity column or change the generation attribute of an existing identity column. See ",(0,i.jsx)(n.a,{href:"/zh/docs/sql-stmts/create-table",children:"CREATE TABLE"})," for details."]}),"\n",(0,i.jsxs)(n.p,{children:["If ",(0,i.jsx)(n.code,{children:"DROP IDENTITY IF EXISTS"})," is specified and the column is not an identity column, no error is thrown. In this case Cloudberry Database issues a notice instead."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"SET sequence_option"})}),(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"RESTART"})})]}),"\n",(0,i.jsxs)(n.p,{children:["These forms alter the sequence that underlies an existing identity column. sequence_option is an option supported by ",(0,i.jsx)(n.a,{href:"/zh/docs/sql-stmts/alter-sequence",children:"ALTER SEQUENCE"})," such as ",(0,i.jsx)(n.code,{children:"INCREMENT BY"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"SET STATISTICS"})})}),"\n",(0,i.jsxs)(n.p,{children:["Sets the per-column statistics-gathering target for subsequent ",(0,i.jsx)(n.a,{href:"/zh/docs/sql-stmts/analyze",children:"ANALYZE"})," operations. The target can be set in the range 0 to 10000, or set to -1 to revert to using the system default statistics target (",(0,i.jsx)(n.code,{children:"default_statistics_target"}),"). When set to 0, no statistics are collected."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"SET STATISTICS"})," acquires a ",(0,i.jsx)(n.code,{children:"SHARE UPDATE EXCLUSIVE"})," lock."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"SET ( attribute_option = value [, ... ] )"})}),(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"RESET ( attribute_option [, ...] )"})})]}),"\n",(0,i.jsxs)(n.p,{children:["Sets or resets per-attribute options. Currently, the only defined per-attribute options are ",(0,i.jsx)(n.code,{children:"n_distinct"})," and ",(0,i.jsx)(n.code,{children:"n_distinct_inherited"}),", which override the number-of-distinct-values estimates made by subsequent ",(0,i.jsx)(n.a,{href:"/zh/docs/sql-stmts/analyze",children:"ANALYZE"})," operations. ",(0,i.jsx)(n.code,{children:"n_distinct"})," affects the statistics for the table itself, while ",(0,i.jsx)(n.code,{children:"n_distinct_inherited"})," affects the statistics gathered for the table plus its inheritance children. When set to a positive value, ",(0,i.jsx)(n.code,{children:"ANALYZE"})," assumes that the column contains exactly the specified number of distinct non-null values. When set to a negative value, which must be greater than or equal to -1, ",(0,i.jsx)(n.code,{children:"ANALYZE"})," assumes that the number of distinct non-null values in the column is linear in the size of the table; the exact count is to be computed by multiplying the estimated table size by the absolute value of the given number. For example, a value of -1 implies that all values in the column are distinct, while a value of -0.5 implies that each value appears twice on the average. This can be useful when the size of the table changes over time, since the multiplication by the number of rows in the table is not performed until query planning time. Specify the value 0 to revert to estimating the number of distinct values normally."]}),"\n",(0,i.jsxs)(n.p,{children:["Changing per-attribute options acquires a ",(0,i.jsx)(n.code,{children:"SHARE UPDATE EXCLUSIVE"})," lock."]}),"\n",(0,i.jsxs)(n.p,{children:["Do not use this form of ",(0,i.jsx)(n.code,{children:"SET"})," to set attribute encoding options for appendoptimized, column-oriented tables. Instead, use  ",(0,i.jsx)(n.code,{children:"ALTER COLUMN ... SET ENCODING ..."}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"SET STORAGE"})})}),"\n",(0,i.jsxs)(n.p,{children:["This form sets the storage mode for a column. This controls whether this column is held inline or in a secondary TOAST table, and whether the data should be compressed or not. ",(0,i.jsx)(n.code,{children:"PLAIN"})," must be used for fixed-length values such as integer and is inline, uncompressed. ",(0,i.jsx)(n.code,{children:"MAIN"})," is for inline, compressible data. ",(0,i.jsx)(n.code,{children:"EXTERNAL"})," is for external, uncompressed data, and ",(0,i.jsx)(n.code,{children:"EXTENDED"})," is for external, compressed data. ",(0,i.jsx)(n.code,{children:"EXTENDED"})," is the default for most data types that support non-",(0,i.jsx)(n.code,{children:"PLAIN"})," storage. Use of ",(0,i.jsx)(n.code,{children:"EXTERNAL"})," will make substring operations on very large text and bytea values run faster, at the penalty of increased storage space. Note that ",(0,i.jsx)(n.code,{children:"SET STORAGE"})," doesn't itself change anything in the table, it just sets the strategy to be pursued during future table updates."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"SET ENCODING ( storage_directive> [, ...] )"})})}),"\n",(0,i.jsx)(n.p,{children:"This form sets column encoding options for append-optimized, column-oriented tables."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"ADD table_constraint [ NOT VALID ]"})})}),"\n",(0,i.jsxs)(n.p,{children:["Adds a new constraint to a table using the same syntax as ",(0,i.jsx)(n.a,{href:"/zh/docs/sql-stmts/create-table",children:"CREATE TABLE"}),". The ",(0,i.jsx)(n.code,{children:"NOT VALID"})," option is currently allowed only for foreign key and ",(0,i.jsx)(n.code,{children:"CHECK"})," constraints."]}),"\n",(0,i.jsxs)(n.p,{children:["Normally, this form causes a scan of the table to verify that all existing rows in the table satisfy the new constraint.  If the constraint is marked ",(0,i.jsx)(n.code,{children:"NOT VALID"}),", Cloudberry Database skips the potentially-lengthy initial check to verify that all rows in the table satisfy the constraint. The constraint will still be enforced against subsequent inserts or updates (that is, they'll fail unless there is a matching row in the referenced table, in the case of foreign keys; and they'll fail unless the new row matches the specified check constraints). But the database will not assume that the constraint holds for all rows in the table, until it is validated by using the ",(0,i.jsx)(n.code,{children:"VALIDATE CONSTRAINT"})," option. See the ",(0,i.jsx)(n.a,{href:"#notes",children:"Notes"})," for more information about using the ",(0,i.jsx)(n.code,{children:"NOT VALID"})," option."]}),"\n",(0,i.jsxs)(n.p,{children:["Most forms of ",(0,i.jsx)(n.code,{children:"ADD <table_constraint>"})," require an ",(0,i.jsx)(n.code,{children:"ACCESS EXCLUSIVE"})," lock."]}),"\n",(0,i.jsxs)(n.p,{children:["Additional restrictions apply when unique or primary key constraints are added to partitioned tables; see ",(0,i.jsx)(n.a,{href:"/zh/docs/sql-stmts/create-table",children:"CREATE TABLE"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"ADD table_constraint_using_index"})})}),"\n",(0,i.jsxs)(n.p,{children:["This form adds a new ",(0,i.jsx)(n.code,{children:"PRIMARY KEY"})," or ",(0,i.jsx)(n.code,{children:"UNIQUE"})," constraint to a table based on an existing unique index. All the columns of the index will be included in the constraint."]}),"\n",(0,i.jsxs)(n.p,{children:["The index cannot have expression columns nor be a partial index. Also, it must be a b-tree index with default sort ordering. These restrictions ensure that the index is equivalent to one that would be built by a regular ",(0,i.jsx)(n.code,{children:"ADD PRIMARY KEY"})," or ",(0,i.jsx)(n.code,{children:"ADD UNIQUE"})," command."]}),"\n",(0,i.jsxs)(n.p,{children:["If ",(0,i.jsx)(n.code,{children:"PRIMARY KEY"})," is specified, and the index's columns are not already marked ",(0,i.jsx)(n.code,{children:"NOT NULL"}),", then this command attempts to ",(0,i.jsx)(n.code,{children:"ALTER COLUMN SET NOT NULL"})," against each such column. That requires a full table scan to verify the column(s) contain no nulls. In all other cases, this is a fast operation."]}),"\n",(0,i.jsx)(n.p,{children:"If a constraint name is provided then Cloudberry Database renames the index to match the constraint name. Otherwise the constraint will be named the same as the index."}),"\n",(0,i.jsxs)(n.p,{children:['After this command is executed, the index is "owned" by the constraint, in the same way as if the index had been built by a regular ',(0,i.jsx)(n.code,{children:"ADD PRIMARY KEY"})," or ",(0,i.jsx)(n.code,{children:"ADD UNIQUE"})," command. In particular, dropping the constraint will make the index disappear too."]}),"\n",(0,i.jsx)(n.p,{children:"This form is not currently supported on partitioned tables."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"ALTER CONSTRAINT"})})}),"\n",(0,i.jsx)(n.p,{children:"This form alters the attributes of a constraint that was previously created. Currently only foreign key constraints may be altered, which Cloudberry Database will accept, but not enforce."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"VALIDATE CONSTRAINT"})})}),"\n",(0,i.jsxs)(n.p,{children:["This form validates a foreign key constraint that was previously created as ",(0,i.jsx)(n.code,{children:"NOT VALID"}),", by scanning the table to ensure there are no rows for which the constraint is not satisfied. Nothing happens if the constraint is already marked valid. The advantage of separating validation from initial creation of the constraint is that validation requires a lesser lock on the table than constraint creation does."]}),"\n",(0,i.jsxs)(n.p,{children:["This command acquires a ",(0,i.jsx)(n.code,{children:"SHARE UPDATE EXCLUSIVE"})," lock."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"DROP CONSTRAINT [IF EXISTS]"})})}),"\n",(0,i.jsxs)(n.p,{children:["Drops the specified constraint on a table, along with any index underlying the constraint. If ",(0,i.jsx)(n.code,{children:"IF EXISTS"})," is specified and the constraint does not exist, no error is thrown. Cloudberry Database issues a notice in this case instead."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"DISABLE ROW LEVEL SECURITY"})}),(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"ENABLE ROW LEVEL SECURITY"})})]}),"\n",(0,i.jsxs)(n.p,{children:["These forms control the application of row security policies belonging to the table. If enabled and no policies exist for the table, then Cloudberry Database applies a default-deny policy. Note that policies can exist for a table even if row level security is disabled - in this case, the policies will NOT be applied and the policies will be ignored. See also ",(0,i.jsx)(n.a,{href:"/zh/docs/sql-stmts/create-policy",children:"CREATE POLICY"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"NO FORCE ROW LEVEL SECURITY"})}),(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"FORCE ROW LEVEL SECURITY"})})]}),"\n",(0,i.jsxs)(n.p,{children:["These forms control the application of row security policies belonging to the table when the user is the table owner. If enabled, row level security policies will be applied when the user is the table owner. If disabled (the default) then row level security will not be applied when the user is the table owner. See also ",(0,i.jsx)(n.a,{href:"/zh/docs/sql-stmts/create-policy",children:"CREATE POLICY"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"CLUSTER ON"})})}),"\n",(0,i.jsxs)(n.p,{children:["Selects the default index for future ",(0,i.jsx)(n.a,{href:"/zh/docs/sql-stmts/cluster",children:"CLUSTER"})," operations. It does not actually re-cluster the table."]}),"\n",(0,i.jsxs)(n.p,{children:["Changing cluster options acquires a ",(0,i.jsx)(n.code,{children:"SHARE UPDATE EXCLUSIVE"})," lock."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"REPACK BY COLUMNS"})})}),"\n",(0,i.jsxs)(n.p,{children:["Physically reorders a table based on one or more columns to improve physical correlation. You specify one or more columns, and an optional column order. If not specified, the default is ",(0,i.jsx)(n.code,{children:"ASC"}),". The command is equivalent to the ",(0,i.jsx)(n.a,{href:"/zh/docs/sql-stmts/cluster",children:"CLUSTER"})," command, but it uses the provided column list instead of an index to determine the sorting order."]}),"\n",(0,i.jsxs)(n.p,{children:["The command is especially useful for tables that are loaded in small batches. You may combine ",(0,i.jsx)(n.code,{children:"REPACK BY COLUMNS"})," with most other ",(0,i.jsx)(n.code,{children:"ALTER TABLE"})," commands that do not require a rewrite of the table. You may use ",(0,i.jsx)(n.code,{children:"REPACK BY COLUMNS"})," to add compression or change the existing compression settings of a table while physically reordering the table, which results in better compression and storage. See ",(0,i.jsx)(n.a,{href:"#examples",children:"Examples"})," for more details."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"SET WITHOUT CLUSTER"})})}),"\n",(0,i.jsxs)(n.p,{children:["Removes the most recently used ",(0,i.jsx)(n.a,{href:"/zh/docs/sql-stmts/cluster",children:"CLUSTER"})," index specification from the table. This affects future cluster operations that do not specify an index."]}),"\n",(0,i.jsxs)(n.p,{children:["Changing cluster options acquires a ",(0,i.jsx)(n.code,{children:"SHARE UPDATE EXCLUSIVE"})," lock."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"SET TABLESPACE"})})}),"\n",(0,i.jsxs)(n.p,{children:["Changes the table's tablespace to the specified tablespace and moves the data file(s) associated with the table to the new tablespace. Indexes on the table, if any, are not moved; but they can be moved separately with additional ",(0,i.jsx)(n.code,{children:"SET TABLESPACE"})," commands. When applied to a partitioned table, nothing is moved, but any partitions created afterwards with ",(0,i.jsx)(n.code,{children:"CREATE TABLE ... PARTITION OF"})," will use that tablespace, unless the ",(0,i.jsx)(n.code,{children:"TABLESPACE"})," clause is used to override it."]}),"\n",(0,i.jsxs)(n.p,{children:["All tables in the current database in a tablespace can be moved by using the ",(0,i.jsx)(n.code,{children:"ALL IN TABLESPACE"})," form, which will lock all tables to be moved first and then move each one. This form also supports ",(0,i.jsx)(n.code,{children:"OWNED BY"}),", which will only move tables owned by the roles specified. If the ",(0,i.jsx)(n.code,{children:"NOWAIT"})," option is specified then the command will fail if it is unable to acquire all of the locks required immediately. Note that system catalogs are not moved by this command, use ",(0,i.jsx)(n.code,{children:"ALTER DATABASE"})," or explicit ",(0,i.jsx)(n.code,{children:"ALTER TABLE"})," invocations instead if desired. The ",(0,i.jsx)(n.code,{children:"information_schema"})," relations are not considered part of the system catalogs and will be moved. See also ",(0,i.jsx)(n.a,{href:"/zh/docs/sql-stmts/create-tablespace",children:"CREATE TABLESPACE"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"If changing the tablespace of a partitioned table, all child tables will also be moved to the new tablespace."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"SET { LOGGED | UNLOGGED }"})})}),"\n",(0,i.jsx)(n.p,{children:"This form changes the table from unlogged to logged or vice-versa. It cannot be applied to a temporary table."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"SET ( storage_\\parameter [= value] [, ... ] )"})})}),"\n",(0,i.jsxs)(n.p,{children:["This form changes one or more table-level options. See ",(0,i.jsx)(n.a,{href:"/zh/docs/sql-stmts/create-table#storage-parameters",children:"Storage Parameters"})," in the ",(0,i.jsx)(n.code,{children:"CREATE TABLE"})," reference for details on the available parameters. Note that for heap tables, the table contents will not be modified immediately by this command; depending on the parameter, you may need to rewrite the table to get the desired effects. That can be done with ",(0,i.jsx)(n.a,{href:"/zh/docs/sql-stmts/vacuum",children:"VACUUM FULL"}),", ",(0,i.jsx)(n.a,{href:"/zh/docs/sql-stmts/cluster",children:"CLUSTER"})," or one of the forms of ",(0,i.jsx)(n.code,{children:"ALTER TABLE"})," that forces a table rewrite, see ",(0,i.jsx)(n.a,{href:"#notes",children:"Notes"}),". For append-optimized column-oriented tables, changing a storage parameter always results in a table rewrite. For planner-related parameters, changes take effect from the next time the table is locked, so currently executing queries are not affected."]}),"\n",(0,i.jsxs)(n.p,{children:["Cloudberry Database takes a ",(0,i.jsx)(n.code,{children:"SHARE UPDATE EXCLUSIVE"})," lock when setting ",(0,i.jsx)(n.code,{children:"fillfactor"}),", toast and autovacuum storage parameters, and the planner parameter ",(0,i.jsx)(n.code,{children:"parallel_workers"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"RESET ( storage_parameter [, ... ] )"})})}),"\n",(0,i.jsxs)(n.p,{children:["This form resets one or more table level options to their defaults. As with ",(0,i.jsx)(n.code,{children:"SET"}),", a table rewrite might be required to update the table entirely."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"SET WITH (<set_with_parameter> = <value> [, ...])"})})}),"\n",(0,i.jsx)(n.p,{children:"You can use this form of the command to reorganize the table, or to set the table access method and also optionally set storage parameters."}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Note:"})}),"\n",(0,i.jsxs)(n.p,{children:["Although you can specify the table's access method using the ",(0,i.jsx)(n.code,{children:"appendoptimized"})," and ",(0,i.jsx)(n.code,{children:"orientation"})," storage parameters, we recommend that you use ",(0,i.jsx)(n.code,{children:"SET ACCESS METHOD <access_method>"})," instead."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"INHERIT parent_table"})})}),"\n",(0,i.jsxs)(n.p,{children:["Adds the target table as a new child of the specified parent table. Queries against the parent will include records of the target table. To be added as a child, the target table must already contain all of the same columns as the parent (it could have additional columns, too). The columns must have matching data types, and if they have ",(0,i.jsx)(n.code,{children:"NOT NULL"})," constraints in the parent then they must also have ",(0,i.jsx)(n.code,{children:"NOT NULL"})," constraints in the child."]}),"\n",(0,i.jsxs)(n.p,{children:["There must also be matching child-table constraints for all ",(0,i.jsx)(n.code,{children:"CHECK"})," constraints of the parent, except those marked non-inheritable (that is, created with ",(0,i.jsx)(n.code,{children:"ALTER TABLE ... ADD CONSTRAINT ... NO INHERIT"}),") in the parent, which are ignored; all child-table constraints matched must not be marked non-inheritable. ",(0,i.jsx)(n.code,{children:"UNIQUE"}),", ",(0,i.jsx)(n.code,{children:"PRIMARY KEY"}),", and ",(0,i.jsx)(n.code,{children:"FOREIGN KEY"})," constraints are not currently considered."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"NO INHERIT parent_table"})})}),"\n",(0,i.jsx)(n.p,{children:"This form removes the target table from the list of children of the specified parent table. Queries against the parent table will no longer include records drawn from the target table."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"OF type_name"})})}),"\n",(0,i.jsxs)(n.p,{children:["This form links the table to a composite type as though ",(0,i.jsx)(n.code,{children:"CREATE TABLE OF"})," had formed it. The table's list of column names and types must precisely match that of the composite type. The table must not inherit from any other table. These restrictions ensure that ",(0,i.jsx)(n.code,{children:"CREATE TABLE OF"})," would permit an equivalent table definition."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"NOT OF"})})}),"\n",(0,i.jsx)(n.p,{children:"This form dissociates a typed table from its type."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"OWNER TO"})})}),"\n",(0,i.jsx)(n.p,{children:"Changes the owner of the table, sequence, view, materialized view, or foreign table to the specified user."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"RENAME"})})}),"\n",(0,i.jsx)(n.p,{children:"Changes the name of a table (or an index, sequence, view, materialized view, or foreign table), the name of an individual column in a table, or the name of a constraint of the table. When renaming a constraint that has an underlying index, the index is renamed as well. There is no effect on the stored data."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"SET SCHEMA"})})}),"\n",(0,i.jsx)(n.p,{children:"Moves the table into another schema. Associated indexes, constraints, and sequences owned by table columns are moved as well."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"SET DISTRIBUTED"})})}),"\n",(0,i.jsxs)(n.p,{children:["Changes the distribution policy of a table. Changing a hash distribution policy, or changing to or from a replicated policy, will cause the table data to be physically redistributed on disk, which can be resource intensive. If you declare the same hash distribution policy or change from hash to random distribution, data will not be redistributed unless you declare ",(0,i.jsx)(n.code,{children:"SET WITH (reorganize=true)"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"While Cloudberry Database permits changing the distribution policy of a writable external table, the operation never results in physical redistribution of the external data."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"ATTACH PARTITION partition_name { FOR VALUES partition_bound_spec | DEFAULT }"})})}),"\n",(0,i.jsxs)(n.p,{children:["This form of the ",(0,i.jsx)(n.em,{children:"modern partitioning syntax"})," attaches an existing table (which might itself be partitioned) as a partition of the target table. The table can be attached as a partition for specific values using ",(0,i.jsx)(n.code,{children:"FOR VALUES"})," or as a default partition by using ",(0,i.jsx)(n.code,{children:"DEFAULT"}),". For each index in the target table, a corresponding one will be created in the attached table; or, if an equivalent index already exists, it will be attached to the target table's index, as if you had run ",(0,i.jsx)(n.code,{children:"ALTER INDEX ATTACH PARTITION"}),". Note that if the existing table is a foreign table, Cloudberry does not permit attaching the table as a partition of the target table if there are ",(0,i.jsx)(n.code,{children:"UNIQUE"})," indexes on the target table. (See also ",(0,i.jsx)(n.a,{href:"/zh/docs/sql-stmts/create-foreign-table",children:"CREATE FOREIGN TABLE"}),".)"]}),"\n",(0,i.jsxs)(n.p,{children:["A partition using ",(0,i.jsx)(n.code,{children:"FOR VALUES"})," uses the same syntax for partition_bound_spec> as ",(0,i.jsx)(n.a,{href:"/zh/docs/sql-stmts/create-table",children:"CREATE TABLE"}),". The partition bound specification must correspond to the partitioning strategy and partition key of the target table. The table to be attached must have all the same columns as the target table and no more; moreover, the column types must also match. Also, it must have all of the ",(0,i.jsx)(n.code,{children:"NOT NULL"})," and ",(0,i.jsx)(n.code,{children:"CHECK"})," constraints of the target table. Currently ",(0,i.jsx)(n.code,{children:"FOREIGN KEY"})," constraints are not considered. ",(0,i.jsx)(n.code,{children:"UNIQUE"})," and ",(0,i.jsx)(n.code,{children:"PRIMARY KEY"})," constraints from the parent table will be created in the partition, if they don't already exist. If any of the ",(0,i.jsx)(n.code,{children:"CHECK"})," constraints of the table being attached are marked ",(0,i.jsx)(n.code,{children:"NO INHERIT"}),", the command will fail; such constraints must be recreated without the ",(0,i.jsx)(n.code,{children:"NO INHERIT"})," clause."]}),"\n",(0,i.jsxs)(n.p,{children:["If the new partition is a regular table, Cloudberry Database performs a full table scan to check that existing rows in the table do not violate the partition constraint. It is possible to avoid this scan by adding a valid ",(0,i.jsx)(n.code,{children:"CHECK"})," constraint to the table that allows only rows satisfying the desired partition constraint before running this command. The ",(0,i.jsx)(n.code,{children:"CHECK"})," constraint will be used to determine that the table need not be scanned to validate the partition constraint. This does not work, however, if any of the partition keys is an expression and the partition does not accept ",(0,i.jsx)(n.code,{children:"NULL"})," values. If attaching a list partition that will not accept ",(0,i.jsx)(n.code,{children:"NULL"})," values, also add a ",(0,i.jsx)(n.code,{children:"NOT NULL"})," constraint to the partition key column, unless it's an expression."]}),"\n",(0,i.jsxs)(n.p,{children:["If the new partition is a foreign table, nothing is done to verify that all of the rows in the foreign table obey the partition constraint. (See the discussion in ",(0,i.jsx)(n.a,{href:"/zh/docs/sql-stmts/create-foreign-table",children:"CREATE FOREIGN TABLE"})," about constraints on the foreign table.)"]}),"\n",(0,i.jsxs)(n.p,{children:["When a table has a default partition, defining a new partition changes the partition constraint for the default partition. The default partition can't contain any rows that would need to be moved to the new partition, and will be scanned to verify that none are present. This scan, like the scan of the new partition, can be avoided if an appropriate ",(0,i.jsx)(n.code,{children:"CHECK"})," constraint is present. Also like the scan of the new partition, it is always skipped when the default partition is a foreign table."]}),"\n",(0,i.jsxs)(n.p,{children:["Attaching a partition acquires a ",(0,i.jsx)(n.code,{children:"SHARE UPDATE EXCLUSIVE"})," lock on the parent table, in addition to the ",(0,i.jsx)(n.code,{children:"ACCESS EXCLUSIVE"})," locks on the table being attached and on the default partition (if any)."]}),"\n",(0,i.jsxs)(n.p,{children:["Additional locks must also be held on all sub-partitions if the table being attached is itself a partitioned table. Likewise if the default partition is itself a partitioned table. The locking of the sub-partitions can be avoided by adding a ",(0,i.jsx)(n.code,{children:"CHECK"})," constraint as described in Partitioning Large Tables."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"DETACH PARTITION partition_name"})})}),"\n",(0,i.jsxs)(n.p,{children:["This form of the ",(0,i.jsx)(n.em,{children:"modern partitioning syntax"})," detaches the specified partition of the target table. The detached partition continues to exist as a standalone table, but no longer has any ties to the table from which it was detached. Any indexes that were attached to the target table's indexes are detached."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"ALTER PARTITION | DROP PARTITION | RENAME PARTITION | TRUNCATE PARTITION | ADD PARTITION | SPLIT PARTITION | EXCHANGE PARTITION | SET SUBPARTITION TEMPLATE"})})}),"\n",(0,i.jsxs)(n.p,{children:["These forms of the ",(0,i.jsx)(n.em,{children:"classic partitioning syntax"})," change the structure of a partitioned table. You must go through the parent table to alter one of its child tables."]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Note"})," If you add a partition to a table that has sub-partition encodings, the new partition inherits the storage directives for the sub-partitions."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["You can combine all forms of ",(0,i.jsx)(n.code,{children:"ALTER TABLE"})," that act on a single table into a list of multiple alterations to apply together, except ",(0,i.jsx)(n.code,{children:"RENAME"}),", ",(0,i.jsx)(n.code,{children:"SET SCHEMA"}),", ",(0,i.jsx)(n.code,{children:"ATTACH PARTITION"}),", and ",(0,i.jsx)(n.code,{children:"DETACH PARTITION"}),". For example, it is possible to add several columns and/or alter the type of several columns in a single command. This is particularly useful with large tables, since only one pass over the table need be made."]}),"\n",(0,i.jsxs)(n.p,{children:["You must own the table to use ",(0,i.jsx)(n.code,{children:"ALTER TABLE"}),". To change the schema or tablespace of a table, you must also have ",(0,i.jsx)(n.code,{children:"CREATE"})," privilege on the new schema or tablespace. To add the table as a new child of a parent table, you must own the parent table as well. Also, to attach a table as a new partition of the table, you must own the table being attached. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have ",(0,i.jsx)(n.code,{children:"CREATE"})," privilege on the table's schema. To add a column or alter a column type or use the ",(0,i.jsx)(n.code,{children:"OF"})," clause, you must also have ",(0,i.jsx)(n.code,{children:"USAGE"})," privilege on the data type. A superuser has these privileges automatically."]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Note"})," Memory usage increases significantly when a table has many partitions, if a table has compression, or if the blocksize for a table is large. If the number of relations associated with the table is large, this condition can force an operation on the table to use more memory. For example, if the table is an append-optimized column-oriented table and has a large number of columns, each column is a relation. An operation that accesses all of the columns in the table allocates associated buffers. If the table has 40 columns and 100 partitions, and the columns are compressed and the blocksize is 2 MB (with a system factor of 3), the system attempts to allocate 24 GB, that is (40 \xd7100) \xd7 (2 \xd73) MB or 24 GB."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"parameters",children:"Parameters"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"IF EXISTS"})})}),"\n",(0,i.jsx)(n.p,{children:"Do not throw an error if the table does not exist. Cloudberry Database issues a notice in this case."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"name"})})}),"\n",(0,i.jsxs)(n.p,{children:["The name (possibly schema-qualified) of an existing table to alter. If ",(0,i.jsx)(n.code,{children:"ONLY"})," is specified, only that table is altered. If ",(0,i.jsx)(n.code,{children:"ONLY"})," is not specified, the table and all of its descendant tables (if any) are updated.  You can optionally specify ",(0,i.jsx)(n.code,{children:"*"})," after the table name to explicitly indicate that descendant tables are included."]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Note"})," Adding or dropping a column, or changing a column's type, in a parent or descendant table only is not permitted. The parent table and its descendents must always have the same columns and types."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"column_name"})})}),"\n",(0,i.jsx)(n.p,{children:"Name of a new or existing column. Note that Cloudberry Database distribution key columns must be treated with special care. Altering or dropping these columns can change the distribution policy for the table."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"new_column_name"})})}),"\n",(0,i.jsx)(n.p,{children:"New name for an existing column."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"new_name"})})}),"\n",(0,i.jsx)(n.p,{children:"New name for the table."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"type"})})}),"\n",(0,i.jsxs)(n.p,{children:["Data type of the new column, or new data type for an existing column. If changing the data type of a Cloudberry distribution key column, you are only allowed to change it to a compatible type (for example, ",(0,i.jsx)(n.code,{children:"text"})," to ",(0,i.jsx)(n.code,{children:"varchar"})," is OK, but ",(0,i.jsx)(n.code,{children:"text"})," to ",(0,i.jsx)(n.code,{children:"int"})," is not)."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"table_constraint"})})}),"\n",(0,i.jsx)(n.p,{children:"New table constraint for the table. Note that foreign key constraints are currently not supported in Cloudberry Database. Also a table is only allowed one unique constraint and the uniqueness must be within the Cloudberry Database distribution key."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"constraint_name"})})}),"\n",(0,i.jsx)(n.p,{children:"Name of an existing constraint to drop."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"ENCODING ( <storage_directive> [,...] )"})})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"ENCODING"})," clause is valid only for append-optimized, column-oriented tables."]}),"\n",(0,i.jsxs)(n.p,{children:["When you add a column to an append-optimized, column-oriented table, Cloudberry Database sets each data compression parameter for the column (",(0,i.jsx)(n.code,{children:"compresstype"}),", ",(0,i.jsx)(n.code,{children:"compresslevel"}),", and ",(0,i.jsx)(n.code,{children:"blocksize"}),") based on the following setting, in order of preference."]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["The compression parameter setting specified in the ",(0,i.jsx)(n.code,{children:"ALTER TABLE"})," command ",(0,i.jsx)(n.code,{children:"ENCODING"})," clause."]}),"\n",(0,i.jsxs)(n.li,{children:["The table's data compression setting specified in the ",(0,i.jsx)(n.code,{children:"WITH"})," clause when the table was created."]}),"\n",(0,i.jsx)(n.li,{children:"The compression parameter setting specified in the server configuration parameter gp_default_storage_option."}),"\n",(0,i.jsx)(n.li,{children:"The default compression parameter value."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["For more information about the supported ",(0,i.jsx)(n.code,{children:"ENCODING"})," storage directives, refer to ",(0,i.jsx)(n.a,{href:"/zh/docs/sql-stmts/create-table",children:"CREATE TABLE"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"CASCADE"})})}),"\n",(0,i.jsx)(n.p,{children:"Automatically drop objects that depend on the dropped column or constraint (for example, views referencing the column), and in turn all objects that depend on those objects."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"RESTRICT"})})}),"\n",(0,i.jsx)(n.p,{children:"Refuse to drop the column or constraint if there are any dependent objects. This is the default behavior."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"index_name"})})}),"\n",(0,i.jsx)(n.p,{children:"The name of an existing index."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"storage_parameter"})})}),"\n",(0,i.jsxs)(n.p,{children:["The name of a table storage parameter. Refer to the ",(0,i.jsx)(n.a,{href:"/zh/docs/sql-stmts/create-table#storage-parameters",children:"Storage Parameters"})," section on the ",(0,i.jsx)(n.code,{children:"CREATE TABLE"})," reference page for a list of parameters."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"value"})})}),"\n",(0,i.jsx)(n.p,{children:"The new value for the a table storage parameter. This might be a number or a word, depending on the parameter."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"parent_table"})})}),"\n",(0,i.jsx)(n.p,{children:"A parent table to associate or de-associate with this table."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"new_owner"})})}),"\n",(0,i.jsx)(n.p,{children:"The role name of the new owner of the table."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"new_tablespace"})})}),"\n",(0,i.jsx)(n.p,{children:"The name of the tablespace to which the table will be moved."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"new_schema"})})}),"\n",(0,i.jsx)(n.p,{children:"The name of the schema to which the table will be moved."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"partition_name"})})}),"\n",(0,i.jsx)(n.p,{children:"The name of the table to attach as a new partition or to detach from this table."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"partition_bound_spec"})})}),"\n",(0,i.jsxs)(n.p,{children:["The partition bound specification for a new partition. Refer to ",(0,i.jsx)(n.a,{href:"/zh/docs/sql-stmts/create-table",children:"CREATE TABLE"})," for more details on the syntax of the same."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"access_method"})})}),"\n",(0,i.jsxs)(n.p,{children:["The method to use for accessing the table. Refer to Choosing the Storage Model for more information on the table storage models and access methods available in Cloudberry Database. Set to ",(0,i.jsx)(n.code,{children:"heap"})," to access the table as a heap-storage table, ",(0,i.jsx)(n.code,{children:"ao_row"})," to access the table as an append-optimized table with row-oriented storage (AO), or ",(0,i.jsx)(n.code,{children:"ao_column"})," to access the table as an append-optimized table with column-oriented storage (AO/CO)."]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Note:"})}),"\n",(0,i.jsxs)(n.p,{children:["Although you can specify the table's access method using ",(0,i.jsx)(n.code,{children:"SET <storage_parameter>"}),", we recommend that you use ",(0,i.jsx)(n.code,{children:"SET ACCESS METHOD <access_method>"})," instead."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"SET WITH (reorganize=true|false)"})})}),"\n",(0,i.jsxs)(n.p,{children:["Use ",(0,i.jsx)(n.code,{children:"reorganize=true"})," when the hash distribution policy has not changed or when you have changed from a hash to a random distribution, and you want to redistribute the data anyway."]}),"\n",(0,i.jsxs)(n.p,{children:["If you are setting the distribution policy, you must specify the ",(0,i.jsx)(n.code,{children:"WITH (reorganize=<value>)"})," clause before the ",(0,i.jsx)(n.code,{children:"DISTRIBUTED ..."})," clause."]}),"\n",(0,i.jsx)(n.p,{children:"Any attempt to reorganize an external table fails with an error."}),"\n",(0,i.jsx)(n.h3,{id:"classic-partitioning-syntax-parameters",children:"Classic partitioning syntax parameters"}),"\n",(0,i.jsxs)(n.p,{children:["Descriptions of additional parameters that are specific to the ",(0,i.jsx)(n.em,{children:"classic partitioning syntax"})," follow."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"ALTER [DEFAULT] PARTITION"})})}),"\n",(0,i.jsxs)(n.p,{children:["If altering a partition deeper than the first level of partitions, use ",(0,i.jsx)(n.code,{children:"ALTER PARTITION"})," clauses to specify which sub-partition in the hierarchy you want to alter. For each partition level in the table hierarchy that is above the target partition, specify the partition that is related to the target partition in an ",(0,i.jsx)(n.code,{children:"ALTER PARTITION"})," clause."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"DROP [DEFAULT] PARTITION"})})}),"\n",(0,i.jsx)(n.p,{children:"Drops the specified partition. If the partition has sub-partitions, the sub-partitions are automatically dropped as well."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"TRUNCATE [DEFAULT] PARTITION"})})}),"\n",(0,i.jsx)(n.p,{children:"Truncates the specified partition. If the partition has sub-partitions, the sub-partitions are automatically truncated as well."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"RENAME [DEFAULT] PARTITION"})})}),"\n",(0,i.jsxs)(n.p,{children:["Changes the partition name of a partition (not the relation name). Partitioned tables are created using the naming convention: ",(0,i.jsx)(n.code,{children:"<"}),"parentname",(0,i.jsx)(n.code,{children:">_<"}),"level",(0,i.jsx)(n.code,{children:">_prt_<"}),"partition_name",(0,i.jsx)(n.code,{children:">"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"ADD DEFAULT PARTITION"})})}),"\n",(0,i.jsx)(n.p,{children:"Adds a default partition to an existing partition design. When data does not match to an existing partition, it is inserted into the default partition. Partition designs that do not have a default partition will reject incoming rows that do not match to an existing partition. Default partitions must be given a name."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"ADD PARTITION"})})}),"\n",(0,i.jsx)(n.p,{children:"partition_element - Using the existing partition type of the table (range or list), defines the boundaries of new partition you are adding."}),"\n",(0,i.jsx)(n.p,{children:"name - A name for this new partition."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"VALUES"})," - For list partitions, defines the value(s) that the partition will contain."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"START"})," - For range partitions, defines the starting range value for the partition. By default, start values are ",(0,i.jsx)(n.code,{children:"INCLUSIVE"}),". For example, if you declared a start date of '",(0,i.jsx)(n.code,{children:"2016-01-01"}),"', then the partition would contain all dates greater than or equal to '",(0,i.jsx)(n.code,{children:"2016-01-01"}),"'. The data type of the ",(0,i.jsx)(n.code,{children:"START"})," expression must support a suitable ",(0,i.jsx)(n.code,{children:"+"})," operator, for example ",(0,i.jsx)(n.code,{children:"timestamp"})," or ",(0,i.jsx)(n.code,{children:"integer"})," (not ",(0,i.jsx)(n.code,{children:"float"})," or ",(0,i.jsx)(n.code,{children:"text"}),") if it is defined with the ",(0,i.jsx)(n.code,{children:"EXCLUSIVE"})," keyword. Typically the data type of the ",(0,i.jsx)(n.code,{children:"START"})," expression is the same type as the partition key column. If that is not the case, then you must explicitly cast to the intended data type."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"END"})," - For range partitions, defines the ending range value for the partition. By default, end values are ",(0,i.jsx)(n.code,{children:"EXCLUSIVE"}),". For example, if you declared an end date of '",(0,i.jsx)(n.code,{children:"2016-02-01"}),"', then the partition would contain all dates less than but not equal to '",(0,i.jsx)(n.code,{children:"2016-02-01"}),"'. The data type of the ",(0,i.jsx)(n.code,{children:"END"})," expression must support a suitable ",(0,i.jsx)(n.code,{children:"+"})," operator, for example ",(0,i.jsx)(n.code,{children:"timestamp"})," or ",(0,i.jsx)(n.code,{children:"integer"})," (not ",(0,i.jsx)(n.code,{children:"float"})," or ",(0,i.jsx)(n.code,{children:"text"}),") if it is defined with the ",(0,i.jsx)(n.code,{children:"INCLUSIVE"})," keyword. Typically the data type of the ",(0,i.jsx)(n.code,{children:"END"})," expression is the same type as the partition key column. If that is not the case, then you must explicitly cast to the intended data type."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"WITH"})," - Sets the table storage options for a partition. For example, you may want older partitions to be append-optimized tables and newer partitions to be regular heap tables. See ",(0,i.jsx)(n.a,{href:"/zh/docs/sql-stmts/create-table",children:"CREATE TABLE"})," for a description of the storage options."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"TABLESPACE"})," - The name of the tablespace in which the partition is to be created."]}),"\n",(0,i.jsx)(n.p,{children:"subpartition_spec - Only allowed on partition designs that were created without a sub-partition template. Declares a sub-partition specification for the new partition you are adding. If the partitioned table was originally defined using a sub-partition template, then the template will be used to generate the sub-partitions automatically."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"EXCHANGE [DEFAULT] PARTITION"})})}),"\n",(0,i.jsx)(n.p,{children:"Exchanges another table into the partition hierarchy into the place of an existing partition. In a multi-level partition design, you can only exchange the lowest level partitions (those that contain data)."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"WITH TABLE"})," table_name - The name of the table you are swapping into the partition design. You can exchange a table where the table data is stored in the database. For example, the table is created with the ",(0,i.jsx)(n.code,{children:"CREATE TABLE"})," command. The table must have the same number of columns, column order, column names, column types, and distribution policy as the parent table."]}),"\n",(0,i.jsxs)(n.p,{children:["With the ",(0,i.jsx)(n.code,{children:"EXCHANGE PARTITION"})," clause, you can also exchange a readable external table (created with the ",(0,i.jsx)(n.code,{children:"CREATE EXTERNAL TABLE"})," command) into the partition hierarchy in the place of an existing leaf partition."]}),"\n",(0,i.jsxs)(n.p,{children:["Exchanging a leaf partition with an external table is not supported if the partitioned table contains a column with a check constraint or a ",(0,i.jsx)(n.code,{children:"NOT NULL"})," constraint."]}),"\n",(0,i.jsx)(n.p,{children:"You cannot exchange a partition with a replicated table. Exchanging a partition with a partitioned table or a child partition of a partitioned table is not supported."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"WITH"})," | ",(0,i.jsx)(n.strong,{children:"WITHOUT VALIDATION"})," - No-op (always validate the data against the partition constraint)."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"SET SUBPARTITION TEMPLATE"})})}),"\n",(0,i.jsx)(n.p,{children:"Modifies the sub-partition template for an existing partition. After a new sub-partition template is set, all new partitions added will have the new sub-partition design (existing partitions are not modified)."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"SPLIT DEFAULT PARTITION"})})}),"\n",(0,i.jsx)(n.p,{children:"Splits a default partition. In a multi-level partition, only a range partition can be split, not a list partition, and you can only split the lowest level default partitions (those that contain data). Splitting a default partition creates a new partition containing the values specified and leaves the default partition containing any values that do not match to an existing partition."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"AT"})," - For list partitioned tables, specifies a single list value that should be used as the criteria for the split."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"START"})," - For range partitioned tables, specifies a starting value for the new partition."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"END"})," - For range partitioned tables, specifies an ending value for the new partition."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"INTO"})," - Allows you to specify a name for the new partition. When using the ",(0,i.jsx)(n.code,{children:"INTO"})," clause to split a default partition, the second partition name specified should always be that of the existing default partition. If you do not know the name of the default partition, you can look it up using the pg_partitions view."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"SPLIT PARTITION"})})}),"\n",(0,i.jsx)(n.p,{children:"Splits an existing partition into two partitions. In a multi-level partition, only a range partition can be split, not a list partition, and you can only split the lowest level partitions (those that contain data)."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"AT"})," - Specifies a single value that should be used as the criteria for the split. The partition will be divided into two new partitions with the split value specified being the starting range for the latter partition."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"INTO"})," - Allows you to specify names for the two new partitions created by the split."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"partition_name"})})}),"\n",(0,i.jsx)(n.p,{children:"The given name of a partition. You can obtain the the table names of the leaf partitions of a partitioned table using the `pg_partition_tree() function."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"FOR ('value')"})})}),"\n",(0,i.jsxs)(n.p,{children:["Specifies a partition by declaring a value that falls within the partition boundary specification. If the value declared with ",(0,i.jsx)(n.code,{children:"FOR"})," matches to both a partition and one of its sub-partitions (for example, if the value is a date and the table is partitioned by month and then by day), then ",(0,i.jsx)(n.code,{children:"FOR"})," will operate on the first level where a match is found (for example, the monthly partition). If your intent is to operate on a sub-partition, you must declare so as follows: ",(0,i.jsx)(n.code,{children:"ALTER TABLE name ALTER PARTITION FOR ('2016-10-01') DROP PARTITION FOR ('2016-10-01');"})]}),"\n",(0,i.jsx)(n.h2,{id:"notes",children:"Notes"}),"\n",(0,i.jsxs)(n.p,{children:["The key word ",(0,i.jsx)(n.code,{children:"COLUMN"})," is noise and can be omitted."]}),"\n",(0,i.jsxs)(n.p,{children:["When a column is added with ",(0,i.jsx)(n.code,{children:"ADD COLUMN"}),", all existing rows in the table are initialized with the column's default value, or ",(0,i.jsx)(n.code,{children:"NULL"})," if no ",(0,i.jsx)(n.code,{children:"DEFAULT"})," clause is specified. Adding a column with a non-null default or changing the type of an existing column will require the entire table and indexes to be rewritten. As an exception, if the ",(0,i.jsx)(n.code,{children:"USING"})," clause does not change the column contents and the old type is either binary coercible to the new type or an unconstrained domain over the new type, a table rewrite is not needed, but any indexes on the affected columns must still be rebuilt. Table and/or index rebuilds may take a significant amount of time for a large table; and will temporarily require as much as double the disk space."]}),"\n",(0,i.jsxs)(n.p,{children:["Adding a ",(0,i.jsx)(n.code,{children:"CHECK"})," or ",(0,i.jsx)(n.code,{children:"NOT NULL"})," constraint requires scanning the table to verify that existing rows meet the constraint, but does not require a table rewrite."]}),"\n",(0,i.jsx)(n.p,{children:"Similarly, when attaching a new partition it may be scanned to verify that existing rows meet the partition constraint."}),"\n",(0,i.jsxs)(n.p,{children:["Cloudberry Database provides the option to specify multiple changes in a single ",(0,i.jsx)(n.code,{children:"ALTER TABLE"})," so that multiple table scans or rewrites can be combined into a single pass over the table."]}),"\n",(0,i.jsxs)(n.p,{children:["Scanning a large table to verify a new check constraint can take a long time, and other updates to the table are locked out until the ",(0,i.jsx)(n.code,{children:"ALTER TABLE ADD CONSTRAINT"})," command is committed. The main purpose of the ",(0,i.jsx)(n.code,{children:"NOT VALID"})," constraint option is to reduce the impact of adding a constraint on concurrent updates. With ",(0,i.jsx)(n.code,{children:"NOT VALID"}),", the ",(0,i.jsx)(n.code,{children:"ADD CONSTRAINT"})," command does not scan the table and can be committed immediately. After that, a ",(0,i.jsx)(n.code,{children:"VALIDATE CONSTRAINT"})," command can be issued to verify that existing rows satisfy the constraint. The validation step does not need to lock out concurrent updates, since it knows that other transactions will be enforcing the constraint for rows that they insert or update; only pre-existing rows need to be checked. Hence, validation acquires only a ",(0,i.jsx)(n.code,{children:"SHARE UPDATE EXCLUSIVE"})," lock on the table being altered. In addition to improving concurrency, it can be useful to use ",(0,i.jsx)(n.code,{children:"NOT VALID"})," and ",(0,i.jsx)(n.code,{children:"VALIDATE CONSTRAINT"})," in cases where the table is known to contain pre-existing violations. Once the constraint is in place, no new violations can be inserted, and you can correct the existing problems until ",(0,i.jsx)(n.code,{children:"VALIDATE CONSTRAINT"})," finally succeeds."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"DROP COLUMN"})," form does not physically remove the column, but simply makes it invisible to SQL operations. Subsequent insert and update operations in the table will store a null value for the column. Thus, dropping a column is quick but it will not immediately reduce the on-disk size of your table, as the space occupied by the dropped column is not reclaimed. The space will be reclaimed over time as existing rows are updated. If you drop the system ",(0,i.jsx)(n.code,{children:"oid"})," column, however, the table is rewritten immediately."]}),"\n",(0,i.jsxs)(n.p,{children:["To force immediate reclamation of space occupied by a dropped column, you can run one of the forms of ",(0,i.jsx)(n.code,{children:"ALTER TABLE"})," that performs a rewrite of the whole table. This results in reconstructing each row with the dropped column replaced by a null value."]}),"\n",(0,i.jsxs)(n.p,{children:["This table lists the ",(0,i.jsx)(n.code,{children:"ALTER TABLE"})," operations that require a table rewrite when performed on tables defined with the specified type of table storage."]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Operation (See Note)"}),(0,i.jsx)(n.th,{children:"Append-Optimized, Column-Oriented"}),(0,i.jsx)(n.th,{children:"Append-Optimized"}),(0,i.jsx)(n.th,{children:"Heap"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"ALTER COLUMN TYPE"})}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"Yes"}),(0,i.jsx)(n.td,{children:"Yes"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"ADD COLUMN"})}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"No"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"ALTER COLUMN SET ENCODING"})}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"N/A"}),(0,i.jsx)(n.td,{children:"N/A"})]})]})]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Important"})," The forms of ",(0,i.jsx)(n.code,{children:"ALTER TABLE"})," that perform a table rewrite are not MVCC-safe. After a table rewrite, the table will appear empty to concurrent transactions if they are using a snapshot taken before the rewrite occurred. See ",(0,i.jsx)(n.a,{href:"https://www.postgresql.org/docs/12/mvcc-caveats.html",children:"MVCC Caveats"})," for more details."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Take special care when altering or dropping columns that are part of the Cloudberry Database distribution key as this can change the distribution policy for the table."}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"USING"})," option of ",(0,i.jsx)(n.code,{children:"SET DATA TYPE"})," can actually specify any expression involving the old values of the row; that is, it can refer to other columns as well as the one being converted. This allows very general conversions to be done with the ",(0,i.jsx)(n.code,{children:"SET DATA TYPE"})," syntax. Because of this flexibility, the ",(0,i.jsx)(n.code,{children:"USING"})," expression is not applied to the column's default value (if any); the result might not be a constant expression as required for a default. This means that when there is no implicit or assignment cast from old to new type, ",(0,i.jsx)(n.code,{children:"SET DATA TYPE"})," might fail to convert the default even though a ",(0,i.jsx)(n.code,{children:"USING"})," clause is supplied. In such cases, drop the default with ",(0,i.jsx)(n.code,{children:"DROP DEFAULT"}),", perform the ",(0,i.jsx)(n.code,{children:"ALTER TYPE"}),", and then use ",(0,i.jsx)(n.code,{children:"SET DEFAULT"})," to add a suitable new default. Similar considerations apply to indexes and constraints involving the column."]}),"\n",(0,i.jsxs)(n.p,{children:["If a table has any descendant tables, it is not permitted to add, rename, or change the type of a column in the parent table without doing the same to the descendants. This ensures that the descendants always have columns matching the parent. Similarly, a ",(0,i.jsx)(n.code,{children:"CHECK"})," constraint cannot be renamed in the parent without also renaming it in all descendants, so that ",(0,i.jsx)(n.code,{children:"CHECK"})," constraints also match between the parent and its descendants. (That restriction does not apply to index-based constraints, however.) Also, because selecting from the parent also selects from its descendants, a constraint on the parent cannot be marked valid unless it is also marked valid for those descendants. In all of these cases, ",(0,i.jsx)(n.code,{children:"ALTER TABLE ONLY"})," will be rejected."]}),"\n",(0,i.jsxs)(n.p,{children:["A recursive ",(0,i.jsx)(n.code,{children:"DROP COLUMN"})," operation will remove a descendant table's column only if the descendant does not inherit that column from any other parents and never had an independent definition of the column. A nonrecursive ",(0,i.jsx)(n.code,{children:"DROP COLUMN"})," (",(0,i.jsx)(n.code,{children:"ALTER TABLE ONLY ... DROP COLUMN"}),") never removes any descendant columns, but instead marks them as independently defined rather than inherited. A nonrecursive ",(0,i.jsx)(n.code,{children:"DROP COLUMN"})," command will fail for a partitioned table, because all partitions of a table must have the same columns as the partitioning root."]}),"\n",(0,i.jsxs)(n.p,{children:["The actions for identity columns (",(0,i.jsx)(n.code,{children:"ADD GENERATED"}),", ",(0,i.jsx)(n.code,{children:"SET"})," etc., ",(0,i.jsx)(n.code,{children:"DROP IDENTITY"}),"), as well as the actions ",(0,i.jsx)(n.code,{children:"CLUSTER"}),", ",(0,i.jsx)(n.code,{children:"OWNER"}),", and ",(0,i.jsx)(n.code,{children:"TABLESPACE"})," never recurse to descendant tables; that is, they always act as though ",(0,i.jsx)(n.code,{children:"ONLY"})," were specified. Adding a constraint recurses only for ",(0,i.jsx)(n.code,{children:"CHECK"})," constraints that are not marked ",(0,i.jsx)(n.code,{children:"NO INHERIT"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Cloudberry Database does not currently support foreign key constraints. For a unique constraint to be enforced in Cloudberry Database, the table must be hash-distributed (not ",(0,i.jsx)(n.code,{children:"DISTRIBUTED RANDOMLY"}),"), and all of the distribution key columns must be the same as the initial columns of the unique constraint columns."]}),"\n",(0,i.jsx)(n.p,{children:"Cloudberry Database does not permit changing any part of a system catalog table."}),"\n",(0,i.jsxs)(n.p,{children:["Refer to ",(0,i.jsx)(n.a,{href:"/zh/docs/sql-stmts/create-table",children:"CREATE TABLE"})," for a further description of valid parameters."]}),"\n",(0,i.jsxs)(n.p,{children:["Be aware of the following when altering partitioned tables using the ",(0,i.jsx)(n.em,{children:"classic syntax"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["The table name specified in the ",(0,i.jsx)(n.code,{children:"ALTER TABLE"})," command must be the actual table name of the partition, not the partition alias that is specified in the classic syntax."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Use the ",(0,i.jsx)(n.code,{children:"pg_partition_tree()"})," function to view the structure of a partitioned table. This function returns the partition hierarchy, and can help you identify the particular partitions you may want to alter."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["These ",(0,i.jsx)(n.code,{children:"ALTER PARTITION"})," operations are supported if no data is changed on a partitioned table that contains a leaf partition that has been exchanged to use an external table. Otherwise, an error is returned."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Adding or dropping a column."}),"\n",(0,i.jsx)(n.li,{children:"Changing the data type of column."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["These ",(0,i.jsx)(n.code,{children:"ALTER PARTITION"})," operations are not supported for a partitioned table that contains a leaf partition that has been exchanged to use an external table:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Setting a sub-partition template."}),"\n",(0,i.jsx)(n.li,{children:"Altering the partition properties."}),"\n",(0,i.jsx)(n.li,{children:"Creating a default partition."}),"\n",(0,i.jsx)(n.li,{children:"Setting a distribution policy."}),"\n",(0,i.jsxs)(n.li,{children:["Setting or dropping a ",(0,i.jsx)(n.code,{children:"NOT NULL"})," constraint of column."]}),"\n",(0,i.jsx)(n.li,{children:"Adding or dropping constraints."}),"\n",(0,i.jsx)(n.li,{children:"Splitting an external partition."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,i.jsxs)(n.p,{children:["Add a column of type ",(0,i.jsx)(n.code,{children:"varchar"})," to a table:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"ALTER TABLE distributors ADD COLUMN address varchar(30);\n"})}),"\n",(0,i.jsx)(n.p,{children:"To drop a column from a table:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"ALTER TABLE distributors DROP COLUMN address RESTRICT;\n"})}),"\n",(0,i.jsx)(n.p,{children:"To change the types of two existing columns in one operation:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"ALTER TABLE distributors\n    ALTER COLUMN address TYPE varchar(80),\n    ALTER COLUMN name TYPE varchar(100);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["To change an integer column containing Unix timestamps to ",(0,i.jsx)(n.code,{children:"timestamp with time zone"})," via a ",(0,i.jsx)(n.code,{children:"USING"})," clause:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"ALTER TABLE foo\n    ALTER COLUMN foo_timestamp SET DATA TYPE timestamp with time zone\n    USING\n        timestamp with time zone 'epoch' + foo_timestamp * interval '1 second';\n"})}),"\n",(0,i.jsx)(n.p,{children:"The same, when the column has a default expression that won't automatically cast to the new data type:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"ALTER TABLE foo\n    ALTER COLUMN foo_timestamp DROP DEFAULT,\n    ALTER COLUMN foo_timestamp TYPE timestamp with time zone\n    USING\n        timestamp with time zone 'epoch' + foo_timestamp * interval '1 second',\n    ALTER COLUMN foo_timestamp SET DEFAULT now();\n"})}),"\n",(0,i.jsx)(n.p,{children:"Rename an existing column:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"ALTER TABLE distributors RENAME COLUMN address TO city;\n"})}),"\n",(0,i.jsx)(n.p,{children:"Rename an existing table:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"ALTER TABLE distributors RENAME TO suppliers;\n"})}),"\n",(0,i.jsx)(n.p,{children:"To rename an existing constraint:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"ALTER TABLE distributors RENAME CONSTRAINT zipchk TO zip_check;\n"})}),"\n",(0,i.jsx)(n.p,{children:"Add a not-null constraint to a column:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"ALTER TABLE distributors ALTER COLUMN street SET NOT NULL;\n"})}),"\n",(0,i.jsx)(n.p,{children:"Rename an existing constraint:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"ALTER TABLE distributors RENAME CONSTRAINT zipchk TO zip_check;\n"})}),"\n",(0,i.jsx)(n.p,{children:"To remove a not-null constraint from a column:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"ALTER TABLE distributors ALTER COLUMN street DROP NOT NULL;\n"})}),"\n",(0,i.jsx)(n.p,{children:"Add a check constraint to a table and all of its children:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"ALTER TABLE distributors ADD CONSTRAINT zipchk CHECK \n  (char_length(zipcode) = 5);\n"})}),"\n",(0,i.jsx)(n.p,{children:"To add a check constraint only to a table and not to its children:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"ALTER TABLE distributors ADD CONSTRAINT zipchk CHECK (char_length(zipcode) = 5)\n  NO INHERIT;\n"})}),"\n",(0,i.jsx)(n.p,{children:"(The check constraint will not be inherited by future children, either.)"}),"\n",(0,i.jsx)(n.p,{children:"Remove a check constraint from a table and all of its children:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"ALTER TABLE distributors DROP CONSTRAINT zipchk;\n"})}),"\n",(0,i.jsx)(n.p,{children:"Remove a check constraint from one table only:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"ALTER TABLE ONLY distributors DROP CONSTRAINT zipchk;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["(The check constraint remains in place for any child tables that inherit ",(0,i.jsx)(n.code,{children:"distributors"}),".)"]}),"\n",(0,i.jsx)(n.p,{children:"To add a (multicolumn) unique constraint to a table:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"ALTER TABLE distributors ADD CONSTRAINT dist_id_zipcode_key UNIQUE (dist_id, zipcode);\n"})}),"\n",(0,i.jsx)(n.p,{children:"To add an automatically named primary key constraint to a table, noting that a table can only ever have one primary key:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"ALTER TABLE distributors ADD PRIMARY KEY (dist_id);\n"})}),"\n",(0,i.jsx)(n.p,{children:"To move a table to a different tablespace:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"ALTER TABLE distributors SET TABLESPACE fasttablespace;\n"})}),"\n",(0,i.jsx)(n.p,{children:"Move a table to a different schema:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"ALTER TABLE myschema.distributors SET SCHEMA yourschema;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Change a table's access method to ",(0,i.jsx)(n.code,{children:"ao_row"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"ALTER TABLE distributors SET ACCESS METHOD ao_row;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Change a table's ",(0,i.jsx)(n.code,{children:"blocksize"})," to ",(0,i.jsx)(n.code,{children:"32768"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"ALTER TABLE distributors SET (blocksize = 32768);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Change a table's access method to ",(0,i.jsx)(n.code,{children:"ao_row"}),", compression type to ",(0,i.jsx)(n.code,{children:"zstd"})," and compression level to ",(0,i.jsx)(n.code,{children:"4"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"ALTER TABLE sales SET ACCESS METHOD ao_row with (compresstype=zstd,compresslevel=4);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Alternatively, you can perform the same operation using ",(0,i.jsx)(n.code,{children:"SET WITH"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"ALTER TABLE sales SET WITH (appendoptimized=true, compresstype=zstd, compresslevel=4);\n"})}),"\n",(0,i.jsx)(n.p,{children:"Change access method for all existing partitions of a table:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"ALTER TABLE sales SET ACCESS METHOD ao_row;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Change all future partitions of a table to have an access method of ",(0,i.jsx)(n.code,{children:"heap"}),", leaving the access method of current partitions as is:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"ALTER TABLE ONLY sales SET ACCESS METHOD heap;\n"})}),"\n",(0,i.jsx)(n.p,{children:"Add a column and change the table's access method:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"ALTER TABLE distributors SET ACCESS METHOD ao_row, ADD column j int;\n"})}),"\n",(0,i.jsx)(n.p,{children:"Add a column and change table storage parameters:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"ALTER TABLE distributors SET (compresslevel=7), ADD COLUMN k int;\n"})}),"\n",(0,i.jsx)(n.p,{children:"Change the distribution policy of a table to replicated:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"ALTER TABLE myschema.distributors SET DISTRIBUTED REPLICATED;\n"})}),"\n",(0,i.jsx)(n.p,{children:"Change the distribution policy of a table to random and force a table rewrite:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"ALTER TABLE distributors SET WITH (REORGANIZE=true) SET DISTRIBUTED RANDOMLY;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Set compression for a table and physically reorder the table by column ",(0,i.jsx)(n.code,{children:"i"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"ALTER TABLE distributors \n    REPACK BY COLUMNS (i),\n    SET (compresstype=zstd, compresslevel=3);\n"})}),"\n",(0,i.jsx)(n.h3,{id:"modern-syntax-partioning-examples",children:"Modern syntax partioning examples"}),"\n",(0,i.jsx)(n.p,{children:"Attach a partition to a range-partitioned table:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"ALTER TABLE measurement\n    ATTACH PARTITION measurement_y2016m07 FOR VALUES FROM ('2016-07-01') TO ('2016-08-01');\n"})}),"\n",(0,i.jsx)(n.p,{children:"Attach a partition to a list-partitioned table:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"ALTER TABLE cities\n    ATTACH PARTITION cities_ab FOR VALUES IN ('a', 'b');\n"})}),"\n",(0,i.jsx)(n.p,{children:"Attach a partition to a hash-partitioned table:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"ALTER TABLE orders\n    ATTACH PARTITION orders_p4 FOR VALUES WITH (MODULUS 4, REMAINDER 3);\n"})}),"\n",(0,i.jsx)(n.p,{children:"Attach a default partition to a partitioned table:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"ALTER TABLE cities\n    ATTACH PARTITION cities_partdef DEFAULT;\n"})}),"\n",(0,i.jsx)(n.p,{children:"Detach a partition from a partitioned table:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"ALTER TABLE measurement\n    DETACH PARTITION measurement_y2015m12;\n"})}),"\n",(0,i.jsx)(n.h3,{id:"classic-syntax-partioning-examples",children:"Classic syntax partioning examples"}),"\n",(0,i.jsx)(n.p,{children:"Add a new partition to a partitioned table:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"ALTER TABLE sales ADD PARTITION \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0START (date '2017-02-01') INCLUSIVE \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0END (date '2017-03-01') EXCLUSIVE;\n"})}),"\n",(0,i.jsx)(n.p,{children:"Add a default partition to an existing partition design:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"ALTER TABLE sales ADD DEFAULT PARTITION other;\n"})}),"\n",(0,i.jsx)(n.p,{children:"Rename a partition:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"ALTER TABLE sales RENAME PARTITION FOR ('2016-01-01') TO \njan08;\n"})}),"\n",(0,i.jsx)(n.p,{children:"Exchange a table into your partition design:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"ALTER TABLE sales EXCHANGE PARTITION FOR ('2016-01-01') WITH \nTABLE jan08;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Split the default partition (where the existing default partition's name is ",(0,i.jsx)(n.code,{children:"other"}),") to add a new monthly partition for January 2017:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"ALTER TABLE sales SPLIT DEFAULT PARTITION \n  START ('2017-01-01') INCLUSIVE \n  END ('2017-02-01') EXCLUSIVE \nINTO (PARTITION jan09, PARTITION other);\n"})}),"\n",(0,i.jsx)(n.p,{children:"Split a monthly partition into two with the first partition containing dates January 1-15 and the second partition containing dates January 16-31:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"ALTER TABLE sales SPLIT PARTITION FOR ('2016-01-01')\nAT ('2016-01-16')\nINTO (PARTITION jan081to15, PARTITION jan0816to31);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["For a multi-level partitioned table that consists of three levels, year, quarter, and region, exchange a leaf partition ",(0,i.jsx)(n.code,{children:"region"})," with the table ",(0,i.jsx)(n.code,{children:"region_new"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"ALTER TABLE sales ALTER PARTITION year_1 ALTER PARTITION quarter_4 EXCHANGE PARTITION region WITH TABLE region_new ;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In the previous command, the two ",(0,i.jsx)(n.code,{children:"ALTER PARTITION"})," clauses identify which ",(0,i.jsx)(n.code,{children:"region"})," partition to exchange. Both clauses are required to identify the specific partition to exchange."]}),"\n",(0,i.jsx)(n.h2,{id:"compatibility",children:"Compatibility"}),"\n",(0,i.jsxs)(n.p,{children:["The forms ",(0,i.jsx)(n.code,{children:"ADD"})," (without ",(0,i.jsx)(n.code,{children:"USING INDEX"}),"), ",(0,i.jsx)(n.code,{children:"DROP [COLUMN]"}),", ",(0,i.jsx)(n.code,{children:"DROP IDENTITY"}),", ",(0,i.jsx)(n.code,{children:"RESTART"}),", ",(0,i.jsx)(n.code,{children:"SET DEFAULT"}),", ",(0,i.jsx)(n.code,{children:"SET DATA TYPE"})," (without ",(0,i.jsx)(n.code,{children:"USING"}),"), ",(0,i.jsx)(n.code,{children:"SET GENERATED"}),", and ",(0,i.jsx)(n.code,{children:"SET <sequence_option>"})," conform with the SQL standard. The other forms are Cloudberry Database extensions of the SQL standard. Also, the ability to specify more than one manipulation in a single ",(0,i.jsx)(n.code,{children:"ALTER TABLE"})," command is an extension."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"ALTER TABLE DROP COLUMN"})," can be used to drop the only column of a table, leaving a zero-column table. This is an extension of SQL, which disallows zero-column tables."]}),"\n",(0,i.jsx)(n.h2,{id:"see-also",children:"See also"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"/zh/docs/sql-stmts/create-table",children:"CREATE TABLE"}),", ",(0,i.jsx)(n.a,{href:"/zh/docs/sql-stmts/drop-table",children:"DROP TABLE"})]})]})}function h(e={}){const{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},11151:(e,n,t)=>{t.d(n,{Z:()=>o,a:()=>r});var i=t(67294);const a={},s=i.createContext(a);function r(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);