"use strict";(self.webpackChunkApache_Cloudberry_Incubating_website=self.webpackChunkApache_Cloudberry_Incubating_website||[]).push([[643],{50269:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>c,toc:()=>l});var t=s(85893),i=s(11151);const o={title:"SELECT"},r="SELECT",c={id:"sql-stmts/select",title:"SELECT",description:"Retrieves rows from a table or view.",source:"@site/docs/sql-stmts/select.md",sourceDirName:"sql-stmts",slug:"/sql-stmts/select",permalink:"/docs/sql-stmts/select",draft:!1,unlisted:!1,editUrl:"https://github.com/apache/cloudberry-site/edit/main/docs/sql-stmts/select.md",tags:[],version:"current",lastUpdatedBy:"Dianjin Wang",lastUpdatedAt:1740637488,formattedLastUpdatedAt:"Feb 27, 2025",frontMatter:{title:"SELECT"},sidebar:"docsbars",previous:{title:"SELECT INTO",permalink:"/docs/sql-stmts/select-into"},next:{title:"SET CONSTRAINTS",permalink:"/docs/sql-stmts/set-constraints"}},a={},l=[{value:"Synopsis",id:"synopsis",level:2},{value:"Description",id:"description",level:2},{value:"Parameters",id:"parameters",level:2},{value:"The <code>WITH</code> clause",id:"the-with-clause",level:3},{value:"The <code>FROM</code> clause",id:"the-from-clause",level:3},{value:"The <code>WHERE</code> clause",id:"the-where-clause",level:3},{value:"The <code>GROUP BY</code> clause",id:"the-group-by-clause",level:3},{value:"The <code>HAVING</code> clause",id:"the-having-clause",level:3},{value:"The <code>WINDOW</code> clause",id:"the-window-clause",level:3},{value:"The <code>SELECT</code> list",id:"the-select-list",level:3},{value:"The <code>DISTINCT</code> clause",id:"the-distinct-clause",level:3},{value:"The <code>UNION</code> clause",id:"the-union-clause",level:3},{value:"The <code>INTERSECT</code> clause",id:"the-intersect-clause",level:3},{value:"The <code>EXCEPT</code> clause",id:"the-except-clause",level:3},{value:"The <code>ORDER BY</code> clause",id:"the-order-by-clause",level:3},{value:"The <code>LIMIT</code> clause",id:"the-limit-clause",level:3},{value:"The <code>LOCKING</code> clause",id:"the-locking-clause",level:3},{value:"The table command",id:"the-table-command",level:2},{value:"Examples",id:"examples",level:2},{value:"Compatibility",id:"compatibility",level:2},{value:"See also",id:"see-also",level:2}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"select",children:"SELECT"}),"\n",(0,t.jsx)(n.p,{children:"Retrieves rows from a table or view."}),"\n",(0,t.jsx)(n.h2,{id:"synopsis",children:"Synopsis"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"[ WITH [ RECURSIVE ] <with_query> [, ...] ]\nSELECT [ALL | DISTINCT [ON (<expression> [, ...])]]\n\xa0\xa0[* | <expression> [[AS] <output_name>] [, ...]]\n\xa0\xa0[FROM <from_item> [, ...]]\n\xa0\xa0[WHERE <condition>]\n\xa0\xa0[GROUP BY <grouping_element> [, ...]]\n\xa0\xa0[HAVING <condition> [, ...]]\n\xa0\xa0[WINDOW <window_name> AS (<window_definition>) [, ...] ]\n\xa0\xa0[{UNION | INTERSECT | EXCEPT} [ALL | DISTINCT] <select>]\n\xa0\xa0[ORDER BY <expression> [ASC | DESC | USING <operator>] [NULLS {FIRST | LAST}] [, ...]]\n\xa0\xa0[LIMIT {<count> | ALL}]\n\xa0\xa0[OFFSET <start> [ ROW | ROWS ] ]\n  [FETCH { FIRST | NEXT } [ <count> ] { ROW | ROWS } ONLY]\n\xa0\xa0[FOR {UPDATE | NO KEY UPDATE | SHARE | KEY SHARE} [OF <table_name> [, ...]] [NOWAIT | SKIP LOCKED ] [...]]\n\n-- where <from_item> can be one of:\n\n  [ONLY] <table_name> [ * ] [ [ AS ] <alias> [ ( <column_alias> [, ...] ) ] ]\n      [ TABLESAMPLE <sampling_method> ( <argument> [, ...] ) [ REPEATABLE ( <seed> ) ] ]\n  [LATERAL] ( <select> ) [ AS ] <alias> [( <column_alias> [, ...] ) ]\n  <with_query_name> [ [ AS ] <alias> [ ( <column_alias> [, ...] ) ] ]\n  [LATERAL] <function_name> ( [ <argument> [, ...] ] )\n      [ WITH ORDINALITY ] [ [ AS ] <alias> [ ( <column_alias> [, ...] ) ] ]\n  [LATERAL] <function_name> ( [ <argument> [, ...] ] ) [ AS ] <alias> ( <column_definition> [, ...] )\n  [LATERAL] <function_name> ( [ <argument> [, ...] ] ) AS ( <column_definition> [, ...] )\n  [LATERAL] ROWS FROM( <function_name> ( [ <argument> [, ...] ] ) [ AS ( <column_definition> [, ...] ) ] [, ...] )\n      [ WITH ORDINALITY ] [ [ AS ] <alias> [ ( <column_alias> [, ...] ) ] ]\n  <from_item> <join_type> <from_item> { ON <join_condition> | USING ( <join_column> [, ...] ) }\n  <from_item> NATURAL <join_type> <from_item>\n  <from_item> CROSS JOIN <from_item>\n\n-- where <grouping_element> can be one of:\n\n\xa0\xa0()\n\xa0\xa0<expression>\n\xa0\xa0ROLLUP (<expression> [,...])\n\xa0\xa0CUBE (<expression> [,...])\n\xa0\xa0GROUPING SETS (<grouping_element> [, ...])\n\n-- where <with_query> is:\n\n\xa0\xa0<with_query_name> [( <column_name> [, ...] )] AS ( [ NOT ] MATERIALIZED ] ( <select> | <values> | <insert> | <update> | delete )\n\nTABLE [ ONLY ] <table_name> [ * ]\n"})}),"\n",(0,t.jsx)(n.h2,{id:"description",children:"Description"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"SELECT"})," retrieves rows from zero or more tables. The general processing of ",(0,t.jsx)(n.code,{children:"SELECT"})," is as follows:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["All queries in the ",(0,t.jsx)(n.code,{children:"WITH"})," clause are computed. These effectively serve as temporary tables that can be referenced in the ",(0,t.jsx)(n.code,{children:"FROM"})," list. A ",(0,t.jsx)(n.code,{children:"WITH"})," query that is referenced more than once in ",(0,t.jsx)(n.code,{children:"FROM"})," is computed only once, unless specified otherwise with ",(0,t.jsx)(n.code,{children:"NOT MATERIALIZED"}),". (See ",(0,t.jsx)(n.a,{href:"#the-with-clause",children:"WITH Clause"})," below.)"]}),"\n",(0,t.jsxs)(n.li,{children:["All elements in the ",(0,t.jsx)(n.code,{children:"FROM"})," list are computed. (Each element in the ",(0,t.jsx)(n.code,{children:"FROM"})," list is a real or virtual table.) If more than one element is specified in the ",(0,t.jsx)(n.code,{children:"FROM"})," list, they are cross-joined together. (See ",(0,t.jsx)(n.a,{href:"#the-from-clause",children:"FROM Clause"})," below.)"]}),"\n",(0,t.jsxs)(n.li,{children:["If the ",(0,t.jsx)(n.code,{children:"WHERE"})," clause is specified, all rows that do not satisfy the condition are eliminated from the output. (See ",(0,t.jsx)(n.a,{href:"#the-where-clause",children:"WHERE Clause"})," below.)"]}),"\n",(0,t.jsxs)(n.li,{children:["If the ",(0,t.jsx)(n.code,{children:"GROUP BY"})," clause is specified, or if there are aggregate function calls, the output is combined into groups of rows that match on one or more values, and the results of aggregate functions are computed. If the ",(0,t.jsx)(n.code,{children:"HAVING"})," clause is present, it eliminates groups that do not satisfy the given condition. (See ",(0,t.jsx)(n.a,{href:"#the-group-by-clause",children:"GROUP BY Clause"})," and ",(0,t.jsx)(n.a,{href:"#the-having-clause",children:"HAVING Clause"})," below.)"]}),"\n",(0,t.jsxs)(n.li,{children:["The actual output rows are computed using the ",(0,t.jsx)(n.code,{children:"SELECT"})," output expressions for each selected row or row group. (See ",(0,t.jsx)(n.a,{href:"#the-select-list",children:"SELECT List"})," below.)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"SELECT DISTINCT"})," eliminates duplicate rows from the result. ",(0,t.jsx)(n.code,{children:"SELECT DISTINCT ON"})," eliminates rows that match on all the specified expressions. ",(0,t.jsx)(n.code,{children:"SELECT ALL"})," (the default) will return all candidate rows, including duplicates. (See ",(0,t.jsx)(n.a,{href:"#the-distinct-clause",children:"DISTINCT Clause"})," below.)"]}),"\n",(0,t.jsxs)(n.li,{children:["If a window expression is specified (and optional ",(0,t.jsx)(n.code,{children:"WINDOW"})," clause), the output is organized according to the positional (row) or value-based (range) window frame. (See ",(0,t.jsx)(n.a,{href:"#the-window-clause",children:"WINDOW Clause"})," below.)"]}),"\n",(0,t.jsxs)(n.li,{children:["Using the operators ",(0,t.jsx)(n.code,{children:"UNION"}),", ",(0,t.jsx)(n.code,{children:"INTERSECT"}),", and ",(0,t.jsx)(n.code,{children:"EXCEPT"}),", the output of more than one ",(0,t.jsx)(n.code,{children:"SELECT"})," statement can be combined to form a single result set. The ",(0,t.jsx)(n.code,{children:"UNION"})," operator returns all rows that are in one or both of the result sets. The ",(0,t.jsx)(n.code,{children:"INTERSECT"})," operator returns all rows that are strictly in both result sets. The ",(0,t.jsx)(n.code,{children:"EXCEPT"})," operator returns the rows that are in the first result set but not in the second. In all three cases, duplicate rows are eliminated unless ",(0,t.jsx)(n.code,{children:"ALL"})," is specified. The noise word ",(0,t.jsx)(n.code,{children:"DISTINCT"})," can be added to explicitly specify eliminating duplicate rows. Notice that ",(0,t.jsx)(n.code,{children:"DISTINCT"})," is the default behavior here, even though ",(0,t.jsx)(n.code,{children:"ALL"})," is the default for ",(0,t.jsx)(n.code,{children:"SELECT"})," itself.  (See ",(0,t.jsx)(n.a,{href:"#the-union-clause",children:"UNION Clause"}),", ",(0,t.jsx)(n.a,{href:"#the-intersect-clause",children:"INTERSECT Clause"}),", and ",(0,t.jsx)(n.a,{href:"#the-except-clause",children:"EXCEPT Clause"})," below.)"]}),"\n",(0,t.jsxs)(n.li,{children:["If the ",(0,t.jsx)(n.code,{children:"ORDER BY"})," clause is specified, the returned rows are sorted in the specified order. If ",(0,t.jsx)(n.code,{children:"ORDER BY"})," is not given, the rows are returned in whatever order the system finds fastest to produce. (See ",(0,t.jsx)(n.a,{href:"#the-order-by-clause",children:"ORDER BY Clause"})," below.)"]}),"\n",(0,t.jsxs)(n.li,{children:["If the ",(0,t.jsx)(n.code,{children:"LIMIT"})," (or ",(0,t.jsx)(n.code,{children:"FETCH FIRST"}),") or ",(0,t.jsx)(n.code,{children:"OFFSET"})," clause is specified, the ",(0,t.jsx)(n.code,{children:"SELECT"})," command only returns a subset of the result rows. (See ",(0,t.jsx)(n.a,{href:"#the-limit-clause",children:"LIMIT Clause"})," below.)"]}),"\n",(0,t.jsxs)(n.li,{children:["If ",(0,t.jsx)(n.code,{children:"FOR UPDATE"}),", ",(0,t.jsx)(n.code,{children:"FOR NO KEY UPDATE"}),", ",(0,t.jsx)(n.code,{children:"FOR SHARE"}),", or ",(0,t.jsx)(n.code,{children:"FOR KEY SHARE"})," is specified, the ",(0,t.jsx)(n.code,{children:"SELECT"})," command locks the entire table against concurrent updates when the Global Deadlock Detector is deactivated (the default). When the Global Deadlock Detector is activated, it affects some simple ",(0,t.jsx)(n.code,{children:"SELECT"})," statements that contain a locking clause. (See ",(0,t.jsx)(n.a,{href:"#the-locking-clause",children:"The Locking Clause"})," below.)"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["You must have ",(0,t.jsx)(n.code,{children:"SELECT"})," privilege on each column used in a ",(0,t.jsx)(n.code,{children:"SELECT"})," command. The use of ",(0,t.jsx)(n.code,{children:"FOR NO KEY UPDATE"}),", ",(0,t.jsx)(n.code,{children:"FOR UPDATE"}),", ",(0,t.jsx)(n.code,{children:"FOR SHARE"}),", or ",(0,t.jsx)(n.code,{children:"FOR KEY SHARE"})," requires ",(0,t.jsx)(n.code,{children:"UPDATE"})," privilege as well (for at least one column of each table so selected)."]}),"\n",(0,t.jsx)(n.h2,{id:"parameters",children:"Parameters"}),"\n",(0,t.jsxs)(n.h3,{id:"the-with-clause",children:["The ",(0,t.jsx)(n.code,{children:"WITH"})," clause"]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"WITH"})," clause allows you to specify one or more subqueries that can be referenced by name in the primary query. The subqueries effectively act as temporary tables or views for the duration of the primary query. Each subquery can be a ",(0,t.jsx)(n.code,{children:"SELECT"}),", ",(0,t.jsx)(n.code,{children:"TABLE"}),", ",(0,t.jsx)(n.code,{children:"VALUES"}),", ",(0,t.jsx)(n.code,{children:"INSERT"}),", ",(0,t.jsx)(n.code,{children:"UPDATE"}),", or ",(0,t.jsx)(n.code,{children:"DELETE"})," statement. When writing a data-modifying statement (",(0,t.jsx)(n.code,{children:"INSERT"}),", ",(0,t.jsx)(n.code,{children:"UPDATE"}),", or ",(0,t.jsx)(n.code,{children:"DELETE"}),") in ",(0,t.jsx)(n.code,{children:"WITH"}),", it is usual to include a ",(0,t.jsx)(n.code,{children:"RETURNING"})," clause. It is the output of ",(0,t.jsx)(n.code,{children:"RETURNING"}),", ",(0,t.jsx)(n.em,{children:"not"})," the underlying table that the statement modifies, that forms the temporary table that is read by the primary query. If ",(0,t.jsx)(n.code,{children:"RETURNING"})," is omitted, the statement is still run, but it produces no output so it cannot be referenced as a table by the primary query."]}),"\n",(0,t.jsxs)(n.p,{children:["For a ",(0,t.jsx)(n.code,{children:"SELECT"})," command that includes a ",(0,t.jsx)(n.code,{children:"WITH"})," clause, the clause can contain at most a single clause that modifies table data (",(0,t.jsx)(n.code,{children:"INSERT"}),", ",(0,t.jsx)(n.code,{children:"UPDATE"}),", or ",(0,t.jsx)(n.code,{children:"DELETE"})," command)."]}),"\n",(0,t.jsxs)(n.p,{children:["A name (without schema qualification) must be specified for each ",(0,t.jsx)(n.code,{children:"WITH"})," query. Optionally, you can specify a list of column names; if this is omitted, the names are inferred from the subquery."]}),"\n",(0,t.jsxs)(n.p,{children:["If ",(0,t.jsx)(n.code,{children:"RECURSIVE"})," is specified, it allows a ",(0,t.jsx)(n.code,{children:"SELECT"})," subquery to reference itself by name. Such a subquery must have the form:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"<non_recursive_term> UNION [ALL | DISTINCT] <recursive_term>\n"})}),"\n",(0,t.jsxs)(n.p,{children:["where the recursive self-reference appears on the right-hand side of the ",(0,t.jsx)(n.code,{children:"UNION"}),". Only one recursive self-reference is permitted per query. Recursive data-modifying statements are not supported, but you can use the results of a recursive ",(0,t.jsx)(n.code,{children:"SELECT"})," query in a data-modifying statement."]}),"\n",(0,t.jsxs)(n.p,{children:["If the ",(0,t.jsx)(n.code,{children:"RECURSIVE"})," keyword is specified, the ",(0,t.jsx)(n.code,{children:"WITH"})," queries need not be ordered: a query can reference another query that is later in the list. However, circular references, or mutual recursion, are not supported. Without the ",(0,t.jsx)(n.code,{children:"RECURSIVE"})," keyword, ",(0,t.jsx)(n.code,{children:"WITH"})," queries can reference only sibling ",(0,t.jsx)(n.code,{children:"WITH"})," queries that are earlier in the ",(0,t.jsx)(n.code,{children:"WITH"})," list."]}),"\n",(0,t.jsxs)(n.p,{children:["When there are multiple queries in the ",(0,t.jsx)(n.code,{children:"WITH"})," clause, ",(0,t.jsx)(n.code,{children:"RECURSIVE"})," should be written only once, immediately after ",(0,t.jsx)(n.code,{children:"WITH"}),". It applies to all queries in the ",(0,t.jsx)(n.code,{children:"WITH"})," clause, though it has no effect on queries that do not use recursion or forward references."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"WITH RECURSIVE"})," limitations. These items are not supported:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["A recursive ",(0,t.jsx)(n.code,{children:"WITH"})," clause that contains the following in the ",(0,t.jsx)(n.code,{children:"<recursive_term>"}),".","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Subqueries with a self-reference"}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"DISTINCT"})," clause"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"GROUP BY"})," clause"]}),"\n",(0,t.jsx)(n.li,{children:"A window function"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["A recursive ",(0,t.jsx)(n.code,{children:"WITH"})," clause where the ",(0,t.jsx)(n.code,{children:"<with_query_name>"})," is a part of a set operation."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Following is an example of the set operation limitation. This query returns an error because the set operation ",(0,t.jsx)(n.code,{children:"UNION"})," contains a reference to the table ",(0,t.jsx)(n.code,{children:"foo"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"WITH RECURSIVE foo(i) AS (\n    SELECT 1\n  UNION ALL\n    SELECT i+1 FROM (SELECT * FROM foo UNION SELECT 0) bar\n)\nSELECT * FROM foo LIMIT 5;\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This recursive CTE is allowed because the set operation ",(0,t.jsx)(n.code,{children:"UNION"})," does not have a reference to the CTE ",(0,t.jsx)(n.code,{children:"foo"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"WITH RECURSIVE foo(i) AS (\n    SELECT 1\n  UNION ALL\n    SELECT i+1 FROM (SELECT * FROM bar UNION SELECT 0) bar, foo\n    WHERE foo.i = bar.a\n)\nSELECT * FROM foo LIMIT 5;\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The primary query and the ",(0,t.jsx)(n.code,{children:"WITH"})," queries are all (notionally) run at the same time. This implies that the effects of a data-modifying statement in ",(0,t.jsx)(n.code,{children:"WITH"})," cannot be seen from other parts of the query, other than by reading its ",(0,t.jsx)(n.code,{children:"RETURNING"})," output. If two such data-modifying statements attempt to modify the same row, the results are unspecified."]}),"\n",(0,t.jsxs)(n.p,{children:["A key property of ",(0,t.jsx)(n.code,{children:"WITH"})," queries is that they are evaluated only once per execution of the primary query, even if the primary query refers to them more than once. In particular, data-modifying statements are guaranteed to be run once and only once, regardless of whether the primary query reads all or any of their output."]}),"\n",(0,t.jsxs)(n.p,{children:["However, a ",(0,t.jsx)(n.code,{children:"WITH"})," query can be marked ",(0,t.jsx)(n.code,{children:"NOT MATERIALIZED"})," to remove this guarantee. In that case, the ",(0,t.jsx)(n.code,{children:"WITH"})," query can be folded into the primary query much as though it were a simple sub-",(0,t.jsx)(n.code,{children:"SELECT"})," in the primary query's ",(0,t.jsx)(n.code,{children:"FROM"})," clause. This results in duplicate computations if the primary query refers to that ",(0,t.jsx)(n.code,{children:"WITH"})," query more than once; but if each such use requires only a few rows of the ",(0,t.jsx)(n.code,{children:"WITH"})," query's total output, ",(0,t.jsx)(n.code,{children:"NOT MATERIALIZED"})," can provide a net savings by allowing the queries to be optimized jointly. ",(0,t.jsx)(n.code,{children:"NOT MATERIALIZED"})," is ignored if it is attached to a ",(0,t.jsx)(n.code,{children:"WITH"})," query that is recursive or is not side-effect-free (for example, is not a plain ",(0,t.jsx)(n.code,{children:"SELECT"})," containing no volatile functions)."]}),"\n",(0,t.jsxs)(n.p,{children:["By default, a side-effect-free ",(0,t.jsx)(n.code,{children:"WITH"})," query is folded into the primary query if it is used exactly once in the primary query's ",(0,t.jsx)(n.code,{children:"FROM"})," clause. This allows joint optimization of the two query levels in situations where that should be semantically invisible. However, such folding can be prevented by marking the ",(0,t.jsx)(n.code,{children:"WITH"})," query as ",(0,t.jsx)(n.code,{children:"MATERIALIZED"}),". That might be useful, for example, if the ",(0,t.jsx)(n.code,{children:"WITH"})," query is being used as an optimization fence to prevent the planner from choosing a bad plan. Cloudberry Database versions before 7 never did such folding, so queries written for older versions might rely on ",(0,t.jsx)(n.code,{children:"WITH"})," to act as an optimization fence."]}),"\n",(0,t.jsxs)(n.p,{children:["See WITH Queries (Common Table Expressions) in the ",(0,t.jsx)(n.em,{children:"Cloudberry Database Administrator Guide"})," for additional information."]}),"\n",(0,t.jsxs)(n.h3,{id:"the-from-clause",children:["The ",(0,t.jsx)(n.code,{children:"FROM"})," clause"]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"FROM"})," clause specifies one or more source tables for the ",(0,t.jsx)(n.code,{children:"SELECT"}),". If multiple sources are specified, the result is the Cartesian product (cross join) of all the sources. But usually qualification conditions are added (via ",(0,t.jsx)(n.code,{children:"WHERE"}),") to restrict the returned rows to a small subset of the Cartesian product."]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"FROM"})," clause can contain the following elements:"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"table_name"})})}),"\n",(0,t.jsxs)(n.p,{children:["The name (optionally schema-qualified) of an existing table or view. If ",(0,t.jsx)(n.code,{children:"ONLY"})," is specified before the table name, only that table is scanned. If ",(0,t.jsx)(n.code,{children:"ONLY"})," is not specified, the table and all of its descendant tables (if any) are scanned. Optionally, you can specify ",(0,t.jsx)(n.code,{children:"*"})," after the table name to explicitly indicate that descendant tables are included."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"alias"})})}),"\n",(0,t.jsxs)(n.p,{children:["A substitute name for the ",(0,t.jsx)(n.code,{children:"FROM"})," item containing the alias. An alias is used for brevity or to eliminate ambiguity for self-joins (where the same table is scanned multiple times). When you provide an alias, it completely hides the actual name of the table or function; for example given ",(0,t.jsx)(n.code,{children:"FROM foo AS f"}),", the remainder of the ",(0,t.jsx)(n.code,{children:"SELECT"})," must refer to this ",(0,t.jsx)(n.code,{children:"FROM"})," item as ",(0,t.jsx)(n.code,{children:"f"})," not ",(0,t.jsx)(n.code,{children:"foo"}),". If you specify an alias, you can also specify a column alias list to provide substitute names for one or more columns of the table."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"TABLESAMPLE sampling_method ( argument [, ...] ) [ REPEATABLE ( seed ) ]"})})}),"\n",(0,t.jsxs)(n.p,{children:["A ",(0,t.jsx)(n.code,{children:"TABLESAMPLE"})," clause after a table_name indicates that the specified sampling_method should be used to retrieve a subset of the rows in that table. This sampling precedes the application of any other filters such as ",(0,t.jsx)(n.code,{children:"WHERE"})," clauses. The standard Cloudberry Database distribution includes two sampling methods, ",(0,t.jsx)(n.code,{children:"BERNOULLI"})," and ",(0,t.jsx)(n.code,{children:"SYSTEM"}),". You can install other sampling methods in the database via extensions."]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"BERNOULLI"})," and ",(0,t.jsx)(n.code,{children:"SYSTEM"})," sampling methods each accept a single argument which is the fraction of the table to sample, expressed as a percentage between 0 and 100. This argument can be any real-valued expression. (Other sampling methods might accept more or different arguments.) These two methods each return a randomly-chosen sample of the table that will contain approximately the specified percentage of the table's rows. The ",(0,t.jsx)(n.code,{children:"BERNOULLI"})," method scans the whole table and selects or ignores individual rows independently with the specified probability. The ",(0,t.jsx)(n.code,{children:"SYSTEM"})," method does block-level sampling with each block having the specified chance of being selected; all rows in each selected block are returned. The ",(0,t.jsx)(n.code,{children:"SYSTEM"})," method is significantly faster than the ",(0,t.jsx)(n.code,{children:"BERNOULLI"})," method when small sampling percentages are specified, but it may return a less-random sample of the table as a result of clustering effects."]}),"\n",(0,t.jsxs)(n.p,{children:["The optional ",(0,t.jsx)(n.code,{children:"REPEATABLE"})," clause specifies a seed number or expression to use for generating random numbers within the sampling method. The seed value can be any non-null floating-point value. Two queries that specify the same seed and argument values will select the same sample of the table, if the table has not been changed meanwhile. But different seed values usually produce different samples. If ",(0,t.jsx)(n.code,{children:"REPEATABLE"})," is not specified, then Cloudberry Database selects a new random sample for each query, based upon a system-generated seed. Note that some add-on sampling methods do not accept ",(0,t.jsx)(n.code,{children:"REPEATABLE"}),", and will always produce new samples on each use."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"select"})})}),"\n",(0,t.jsxs)(n.p,{children:["A sub-",(0,t.jsx)(n.code,{children:"SELECT"})," can appear in the ",(0,t.jsx)(n.code,{children:"FROM"})," clause. This acts as though its output were created as a temporary table for the duration of this single ",(0,t.jsx)(n.code,{children:"SELECT"})," command. Note that the sub-",(0,t.jsx)(n.code,{children:"SELECT"})," must be surrounded by parentheses, and an alias ",(0,t.jsx)(n.em,{children:"must"})," be provided for it. A ",(0,t.jsx)(n.a,{href:"/docs/sql-stmts/values",children:"VALUES"}),' command can also be used here. See "Non-standard Clauses" in the ',(0,t.jsx)(n.a,{href:"#compatibility",children:"Compatibility"})," section for limitations of using correlated sub-selects in Cloudberry Database."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"with_query_name"})})}),"\n",(0,t.jsxs)(n.p,{children:["A ",(0,t.jsx)(n.code,{children:"WITH"})," query is referenced in the ",(0,t.jsx)(n.code,{children:"FROM"})," clause by specifying its name, just as though the name were a table name. You can provide an alias in the same way as for a table."]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"WITH"})," query hides a table of the same name for the purposes of the primary query. If necessary, you can refer to a table of the same name by schema-qualifying the table's name."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"function_name"})})}),"\n",(0,t.jsxs)(n.p,{children:["Function calls can appear in the ",(0,t.jsx)(n.code,{children:"FROM"})," clause. (This is especially useful for functions that return result sets, but any function can be used.) This acts as though the function's output were created as a temporary table for the duration of this single ",(0,t.jsx)(n.code,{children:"SELECT"})," command. When you add the optional ",(0,t.jsx)(n.code,{children:"WITH ORDINALITY"})," clause to the function call, Cloudberry Database appends a new column after all of the function's output columns with numbering for each row."]}),"\n",(0,t.jsxs)(n.p,{children:["You can provide an alias in the same way as for a table. If an alias is specified, you can also specify a column alias list to provide substitute names for one or more attributes of the function's composite return type, including the column added by ",(0,t.jsx)(n.code,{children:"ORDINALITY"})," if present."]}),"\n",(0,t.jsxs)(n.p,{children:["You can combine multiple function calls into a single ",(0,t.jsx)(n.code,{children:"FROM"}),"-clause item by surrounding them with ",(0,t.jsx)(n.code,{children:"ROWS FROM( ... )"}),". The output of such an item is the concatenation of the first row from each function, then the second row from each function, etc. If some of the functions produce fewer rows than others, null values are substituted for the missing data, so that the total number of rows returned is always the same as for the function that produced the most rows."]}),"\n",(0,t.jsxs)(n.p,{children:["If the function has been defined as returning the ",(0,t.jsx)(n.code,{children:"record"})," data type, then an alias or the key word ",(0,t.jsx)(n.code,{children:"AS"})," must be present, followed by a column definition list in the form ",(0,t.jsx)(n.code,{children:"( <column_name> <data_type> [, ... ] )"}),". The column definition list must match the actual number and types of columns returned by the function."]}),"\n",(0,t.jsxs)(n.p,{children:["When using the ",(0,t.jsx)(n.code,{children:"ROWS FROM( ... )"})," syntax, if one of the functions requires a column definition list, it's preferred to put the column definition list after the function call inside ",(0,t.jsx)(n.code,{children:"ROWS FROM( ... )"}),". A column definition list can be placed after the ",(0,t.jsx)(n.code,{children:"ROWS FROM( ... )"})," construct only if there's just a single function and no ",(0,t.jsx)(n.code,{children:"WITH ORDINALITY"})," clause."]}),"\n",(0,t.jsxs)(n.p,{children:["To use ",(0,t.jsx)(n.code,{children:"ORDINALITY"})," together with a column definition list, you must use the ",(0,t.jsx)(n.code,{children:"ROWS FROM( ... )"})," syntax and put the column definition list inside ",(0,t.jsx)(n.code,{children:"ROWS FROM( ... )"}),"."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"join_type"})})}),"\n",(0,t.jsx)(n.p,{children:"One of:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"[INNER] JOIN"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"LEFT [OUTER] JOIN"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"RIGHT [OUTER] JOIN"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"FULL [OUTER] JOIN"})}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["For the ",(0,t.jsx)(n.code,{children:"INNER"})," and ",(0,t.jsx)(n.code,{children:"OUTER"})," join types, you must specify a join condition, namely exactly one of ",(0,t.jsx)(n.code,{children:"NATURAL"}),", ",(0,t.jsx)(n.code,{children:"ON <join_condition>"}),", or ",(0,t.jsx)(n.code,{children:"USING ( <join_column> [, ...])"}),". Continue reading for the meaning."]}),"\n",(0,t.jsxs)(n.p,{children:["A JOIN clause combines two ",(0,t.jsx)(n.code,{children:"FROM"}),' items, which for convenience are referred to as "tables", though in reality they can be any type of ',(0,t.jsx)(n.code,{children:"FROM"})," item. Use parentheses if necessary to determine the order of nesting. In the absence of parentheses, ",(0,t.jsx)(n.code,{children:"JOIN"}),"s nest left-to-right. ",(0,t.jsx)(n.code,{children:"JOIN"})," binds more tightly than the commas separating ",(0,t.jsx)(n.code,{children:"FROM"}),"-list items. All of the ",(0,t.jsx)(n.code,{children:"JOIN"})," options are a notational convenience; they do nothing that cannot be achieved with plain ",(0,t.jsx)(n.code,{children:"FROM"})," and ",(0,t.jsx)(n.code,{children:"WHERE"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"LEFT OUTER JOIN"})," returns all rows in the qualified Cartesian product (i.e., all combined rows that pass its join condition), plus one copy of each row in the left-hand table for which there was no right-hand row that passed the join condition. This left-hand row is extended to the full width of the joined table by inserting null values for the right-hand columns. Note that only the ",(0,t.jsx)(n.code,{children:"JOIN"})," clause's own condition is considered while deciding which rows have matches. Outer conditions are applied afterwards."]}),"\n",(0,t.jsxs)(n.p,{children:["Conversely, ",(0,t.jsx)(n.code,{children:"RIGHT OUTER JOIN"})," returns all the joined rows, plus one row for each unmatched right-hand row (extended with nulls on the left). This is just a notational convenience, since you could convert it to a ",(0,t.jsx)(n.code,{children:"LEFT OUTER JOIN"})," by switching the left and right tables."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"FULL OUTER JOIN"})," returns all the joined rows, plus one row for each unmatched left-hand row (extended with nulls on the right), plus one row for each unmatched right-hand row (extended with nulls on the left)."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"ON join_condition"})})}),"\n",(0,t.jsxs)(n.p,{children:["join_condition is an expression resulting in a value of type ",(0,t.jsx)(n.code,{children:"boolean"})," (similar to a ",(0,t.jsx)(n.code,{children:"WHERE"})," clause) that specifies which rows in a join are considered to match."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"USING (join_column [, ...])"})})}),"\n",(0,t.jsxs)(n.p,{children:["A clause of the form ",(0,t.jsx)(n.code,{children:"USING ( a, b, ... )"})," is shorthand for ",(0,t.jsx)(n.code,{children:"ON left_table.a = right_table.a AND left_table.b = right_table.b ..."}),". Also, ",(0,t.jsx)(n.code,{children:"USING"})," implies that only one of each pair of equivalent columns will be included in the join output, not both."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"NATURAL"})})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"NATURAL"})," is shorthand for a ",(0,t.jsx)(n.code,{children:"USING"})," list that mentions all columns in the two tables that have the same names. If there are no common column names, ",(0,t.jsx)(n.code,{children:"NATURAL"})," is equivalent to ",(0,t.jsx)(n.code,{children:"ON TRUE"}),"."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"CROSS JOIN"})})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"CROSS JOIN"})," is equivalent to ",(0,t.jsx)(n.code,{children:"INNER JOIN ON (TRUE)"}),", that is, no rows are removed by qualification. They produce a simple Cartesian product, the same result as you get from listing the two tables at the top level of ",(0,t.jsx)(n.code,{children:"FROM"}),", but restricted by the join condition (if any)."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"LATERAL"})})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"LATERAL"})," key word can precede a sub-",(0,t.jsx)(n.code,{children:"SELECT FROM"})," item. This allows the sub-",(0,t.jsx)(n.code,{children:"SELECT"})," to refer to columns of ",(0,t.jsx)(n.code,{children:"FROM"})," items that appear before it in the ",(0,t.jsx)(n.code,{children:"FROM"})," list. (Without ",(0,t.jsx)(n.code,{children:"LATERAL"}),", Cloudberry Database evaluates each sub-",(0,t.jsx)(n.code,{children:"SELECT"})," independently and so cannot cross-reference any other ",(0,t.jsx)(n.code,{children:"FROM"})," item.)"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"LATERAL"})," can also precede a function-call ",(0,t.jsx)(n.code,{children:"FROM"})," item. In this case it is a noise word, because the function expression can refer to earlier ",(0,t.jsx)(n.code,{children:"FROM"})," items."]}),"\n",(0,t.jsxs)(n.p,{children:["A ",(0,t.jsx)(n.code,{children:"LATERAL"})," item can appear at top level in the ",(0,t.jsx)(n.code,{children:"FROM"})," list, or within a ",(0,t.jsx)(n.code,{children:"JOIN"})," tree. In the latter case it can also refer to any items that are on the left-hand side of a ",(0,t.jsx)(n.code,{children:"JOIN"})," that it is on the right-hand side of."]}),"\n",(0,t.jsxs)(n.p,{children:["When a ",(0,t.jsx)(n.code,{children:"FROM"})," item contains ",(0,t.jsx)(n.code,{children:"LATERAL"})," cross-references, evaluation proceeds as follows: for each row of the ",(0,t.jsx)(n.code,{children:"FROM"})," item providing the cross-referenced column(s), or set of rows of multiple ",(0,t.jsx)(n.code,{children:"FROM"})," items providing the columns, the ",(0,t.jsx)(n.code,{children:"LATERAL"})," item is evaluated using that row or row set's values of the columns. The resulting row(s) are joined as usual with the rows they were computed from. This is repeated for each row or set of rows from the column source table(s)."]}),"\n",(0,t.jsxs)(n.p,{children:["The column source table(s) must be ",(0,t.jsx)(n.code,{children:"INNER"})," or ",(0,t.jsx)(n.code,{children:"LEFT"})," joined to the ",(0,t.jsx)(n.code,{children:"LATERAL"})," item, else there would not be a well-defined set of rows from which to compute each set of rows for the ",(0,t.jsx)(n.code,{children:"LATERAL"})," item. Thus, although a construct such as ",(0,t.jsx)(n.code,{children:"<X> RIGHT JOIN LATERAL <Y>"})," is syntactically valid, Cloudberry Database does not permit ",(0,t.jsx)(n.code,{children:"<Y>"})," to reference ",(0,t.jsx)(n.code,{children:"<X>"}),"."]}),"\n",(0,t.jsxs)(n.h3,{id:"the-where-clause",children:["The ",(0,t.jsx)(n.code,{children:"WHERE"})," clause"]}),"\n",(0,t.jsxs)(n.p,{children:["The optional ",(0,t.jsx)(n.code,{children:"WHERE"})," clause has the general form:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"WHERE <condition>\n"})}),"\n",(0,t.jsxs)(n.p,{children:["where condition is any expression that evaluates to a result of type ",(0,t.jsx)(n.code,{children:"boolean"}),". Any row that does not satisfy this condition will be eliminated from the output. A row satisfies the condition if it returns true when the actual row values are substituted for any variable references."]}),"\n",(0,t.jsxs)(n.h3,{id:"the-group-by-clause",children:["The ",(0,t.jsx)(n.code,{children:"GROUP BY"})," clause"]}),"\n",(0,t.jsxs)(n.p,{children:["The optional ",(0,t.jsx)(n.code,{children:"GROUP BY"})," clause has the general form:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"GROUP BY <grouping_element> [, ...]\n"})}),"\n",(0,t.jsxs)(n.p,{children:["where ",(0,t.jsx)(n.code,{children:"<grouping_element>"})," can be one of:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"()\n<expression>\nROLLUP (<expression> [,...])\nCUBE (<expression> [,...])\nGROUPING SETS ((<grouping_element> [, ...]))\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"GROUP BY"})," condenses into a single row all selected rows that share the same values for the grouped expressions. An expression used inside a grouping_element can be an input column name, or the name or ordinal number of an output column (",(0,t.jsx)(n.code,{children:"SELECT"})," list item), or an arbitrary expression formed from input-column values. In case of ambiguity, a ",(0,t.jsx)(n.code,{children:"GROUP BY"})," name will be interpreted as an input-column name rather than an output column name."]}),"\n",(0,t.jsxs)(n.p,{children:["If any of ",(0,t.jsx)(n.code,{children:"GROUPING SETS"}),", ",(0,t.jsx)(n.code,{children:"ROLLUP"}),", or ",(0,t.jsx)(n.code,{children:"CUBE"})," are present as grouping elements, then the ",(0,t.jsx)(n.code,{children:"GROUP BY"})," clause as a whole defines some number of independent grouping sets. The effect of this is equivalent to constructing a ",(0,t.jsx)(n.code,{children:"UNION ALL"})," between subqueries with the individual grouping sets as their ",(0,t.jsx)(n.code,{children:"GROUP BY"})," clauses. For further details on the handling of grouping sets, refer to ",(0,t.jsx)(n.a,{href:"https://www.postgresql.org/docs/12/queries-table-expressions.html#QUERIES-GROUPING-SETS",children:"GROUPING SETS, CUBE, and ROLLUP"})," in the PostgreSQL documentation."]}),"\n",(0,t.jsxs)(n.p,{children:["Aggregate functions, if any are used, are computed across all rows making up each group, producing a separate value for each group. (If there are aggregate functions but no ",(0,t.jsx)(n.code,{children:"GROUP BY"})," clause, the query is treated as having a single group comprising all of the selected rows.) You can further filter the set of rows fed to each aggregate function by attaching a ",(0,t.jsx)(n.code,{children:"FILTER"})," clause to the aggregate function call. When a ",(0,t.jsx)(n.code,{children:"FILTER"})," clause is present, only those rows matching it are included in the input to that aggregate function."]}),"\n",(0,t.jsxs)(n.p,{children:["When ",(0,t.jsx)(n.code,{children:"GROUP BY"})," is present, or any aggregate functions are present, it is not valid for the ",(0,t.jsx)(n.code,{children:"SELECT"})," list expressions to refer to ungrouped columns except within aggregate functions or when the ungrouped column is functionally dependent on the grouped columns, since there would otherwise be more than one possible value to return for an ungrouped column. A functional dependency exists if the grouped columns (or a subset thereof) are the primary key of the table containing the ungrouped column."]}),"\n",(0,t.jsxs)(n.p,{children:['Keep in mind that all aggregate functions are evaluated before evaluating any "scalar" expressions in the ',(0,t.jsx)(n.code,{children:"HAVING"})," clause or ",(0,t.jsx)(n.code,{children:"SELECT"})," list. This means that, for example, a ",(0,t.jsx)(n.code,{children:"CASE"})," expression cannot be used to skip evaluation of an aggregate function."]}),"\n",(0,t.jsxs)(n.p,{children:["Currently, ",(0,t.jsx)(n.code,{children:"FOR NO KEY UPDATE"}),", ",(0,t.jsx)(n.code,{children:"FOR UPDATE"}),", ",(0,t.jsx)(n.code,{children:"FOR SHARE"}),", and ",(0,t.jsx)(n.code,{children:"FOR KEY SHARE"})," cannot be specified with ",(0,t.jsx)(n.code,{children:"GROUP BY"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Cloudberry Database has the following additional OLAP grouping extensions (often referred to as ",(0,t.jsx)(n.em,{children:"supergroups"}),"):"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"ROLLUP"})})}),"\n",(0,t.jsxs)(n.p,{children:["A ",(0,t.jsx)(n.code,{children:"ROLLUP"})," grouping is an extension to the ",(0,t.jsx)(n.code,{children:"GROUP BY"})," clause that creates aggregate subtotals that roll up from the most detailed level to a grand total, following a list of grouping columns (or expressions). ",(0,t.jsx)(n.code,{children:"ROLLUP"})," takes an ordered list of grouping columns, calculates the standard aggregate values specified in the ",(0,t.jsx)(n.code,{children:"GROUP BY"})," clause, then creates progressively higher-level subtotals, moving from right to left through the list. Finally, it creates a grand total. A ",(0,t.jsx)(n.code,{children:"ROLLUP"})," grouping can be thought of as a series of grouping sets. For example:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"GROUP BY ROLLUP (a,b,c) \n"})}),"\n",(0,t.jsx)(n.p,{children:"is equivalent to:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"GROUP BY GROUPING SETS( (a,b,c), (a,b), (a), () ) \n"})}),"\n",(0,t.jsxs)(n.p,{children:["Notice that the n elements of a ",(0,t.jsx)(n.code,{children:"ROLLUP"})," translate to n+1 grouping sets. Also, the order in which the grouping expressions are specified is significant in a ",(0,t.jsx)(n.code,{children:"ROLLUP"}),"."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"CUBE"})})}),"\n",(0,t.jsxs)(n.p,{children:["A ",(0,t.jsx)(n.code,{children:"CUBE"})," grouping is an extension to the ",(0,t.jsx)(n.code,{children:"GROUP BY"})," clause that creates subtotals for all of the possible combinations of the given list of grouping columns (or expressions). In terms of multidimensional analysis, ",(0,t.jsx)(n.code,{children:"CUBE"})," generates all the subtotals that could be calculated for a data cube with the specified dimensions. For example:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"GROUP BY CUBE (a,b,c) \n"})}),"\n",(0,t.jsx)(n.p,{children:"is equivalent to:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"GROUP BY GROUPING SETS( (a,b,c), (a,b), (a,c), (b,c), (a), \n(b), (c), () ) \n"})}),"\n",(0,t.jsxs)(n.p,{children:["Notice that n elements of a ",(0,t.jsx)(n.code,{children:"CUBE"})," translate to 2n grouping sets. Consider using ",(0,t.jsx)(n.code,{children:"CUBE"})," in any situation requiring cross-tabular reports. ",(0,t.jsx)(n.code,{children:"CUBE"})," is typically most suitable in queries that use columns from multiple dimensions rather than columns representing different levels of a single dimension. For instance, a commonly requested cross-tabulation might need subtotals for all the combinations of month, state, and product."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"GROUPING SETS"})})}),"\n",(0,t.jsxs)(n.p,{children:["You can selectively specify the set of groups that you want to create using a ",(0,t.jsx)(n.code,{children:"GROUPING SETS"})," expression within a ",(0,t.jsx)(n.code,{children:"GROUP BY"})," clause. This allows precise specification across multiple dimensions without computing a whole ",(0,t.jsx)(n.code,{children:"ROLLUP"})," or ",(0,t.jsx)(n.code,{children:"CUBE"}),". For example:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"GROUP BY GROUPING SETS( (a,c), (a,b) )\n"})}),"\n",(0,t.jsxs)(n.p,{children:["If using the grouping extension clauses ",(0,t.jsx)(n.code,{children:"ROLLUP"}),", ",(0,t.jsx)(n.code,{children:"CUBE"}),", or ",(0,t.jsx)(n.code,{children:"GROUPING SETS"}),", two challenges arise. First, how do you determine which result rows are subtotals, and then the exact level of aggregation for a given subtotal. Or, how do you differentiate between result rows that contain both stored ",(0,t.jsx)(n.code,{children:"NULL"}),' values and "NULL" values created by the ',(0,t.jsx)(n.code,{children:"ROLLUP"})," or ",(0,t.jsx)(n.code,{children:"CUBE"}),". Secondly, when duplicate grouping sets are specified in the ",(0,t.jsx)(n.code,{children:"GROUP BY"})," clause, how do you determine which result rows are duplicates? There are two additional grouping functions you can use in the ",(0,t.jsx)(n.code,{children:"SELECT"})," list to help with this:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"grouping(column [, ...])"})," \u2014 The ",(0,t.jsx)(n.code,{children:"grouping"}),' function can be applied to one or more grouping attributes to distinguish super-aggregated rows from regular grouped rows. This can be helpful in distinguishing a "NULL" representing the set of all values in a super-aggregated row from a ',(0,t.jsx)(n.code,{children:"NULL"})," value in a regular row. Each argument in this function produces a bit \u2014 either ",(0,t.jsx)(n.code,{children:"1"})," or ",(0,t.jsx)(n.code,{children:"0"}),", where ",(0,t.jsx)(n.code,{children:"1"})," means the result row is super-aggregated, and ",(0,t.jsx)(n.code,{children:"0"})," means the result row is from a regular grouping. The ",(0,t.jsx)(n.code,{children:"grouping"})," function returns an integer by treating these bits as a binary number and then converting it to a base-10 integer."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"group_id()"})," \u2014 For grouping extension queries that contain duplicate grouping sets, the ",(0,t.jsx)(n.code,{children:"group_id"})," function is used to identify duplicate rows in the output. All ",(0,t.jsx)(n.em,{children:"unique"})," grouping set output rows will have a ",(0,t.jsx)(n.code,{children:"<group_id>"})," value of 0. For each duplicate grouping set detected, the ",(0,t.jsx)(n.code,{children:"group_id"})," function assigns a ",(0,t.jsx)(n.code,{children:"<group_id>"})," number greater than 0. All output rows in a particular duplicate grouping set are identified by the same ",(0,t.jsx)(n.code,{children:"<group_id>"})," number."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.h3,{id:"the-having-clause",children:["The ",(0,t.jsx)(n.code,{children:"HAVING"})," clause"]}),"\n",(0,t.jsxs)(n.p,{children:["The optional ",(0,t.jsx)(n.code,{children:"HAVING"})," clause has the general form:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"HAVING <condition>\n"})}),"\n",(0,t.jsxs)(n.p,{children:["where ",(0,t.jsx)(n.code,{children:"<condition>"})," is the same as specified for the ",(0,t.jsx)(n.code,{children:"WHERE"})," clause."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"HAVING"})," eliminates group rows that do not satisfy the condition. ",(0,t.jsx)(n.code,{children:"HAVING"})," is different from ",(0,t.jsx)(n.code,{children:"WHERE"}),": ",(0,t.jsx)(n.code,{children:"WHERE"})," filters individual rows before the application of ",(0,t.jsx)(n.code,{children:"GROUP BY"}),", while ",(0,t.jsx)(n.code,{children:"HAVING"})," filters group rows created by ",(0,t.jsx)(n.code,{children:"GROUP BY"}),". Each column referenced in ",(0,t.jsx)(n.code,{children:"<condition>"})," must unambiguously reference a grouping column, unless the reference appears within an aggregate function or the ungrouped column is functionally dependent on the grouping columns."]}),"\n",(0,t.jsxs)(n.p,{children:["The presence of ",(0,t.jsx)(n.code,{children:"HAVING"})," turns a query into a grouped query even if there is no ",(0,t.jsx)(n.code,{children:"GROUP BY"})," clause. This is the same as what happens when the query contains aggregate functions but no ",(0,t.jsx)(n.code,{children:"GROUP BY"})," clause. All of the selected rows are considered to form a single group, and the ",(0,t.jsx)(n.code,{children:"SELECT"})," list and ",(0,t.jsx)(n.code,{children:"HAVING"})," clause can only reference table columns from within aggregate functions. Such a query will emit a single row if the ",(0,t.jsx)(n.code,{children:"HAVING"})," condition is true, zero rows if it is not true."]}),"\n",(0,t.jsxs)(n.p,{children:["Currently, ",(0,t.jsx)(n.code,{children:"FOR NO KEY UPDATE"}),", ",(0,t.jsx)(n.code,{children:"FOR UPDATE"}),", ",(0,t.jsx)(n.code,{children:"FOR SHARE"}),", and ",(0,t.jsx)(n.code,{children:"FOR KEY SHARE"})," cannot be specified with ",(0,t.jsx)(n.code,{children:"HAVING"}),"."]}),"\n",(0,t.jsxs)(n.h3,{id:"the-window-clause",children:["The ",(0,t.jsx)(n.code,{children:"WINDOW"})," clause"]}),"\n",(0,t.jsxs)(n.p,{children:["The optional ",(0,t.jsx)(n.code,{children:"WINDOW"})," clause specifies the behavior of window functions appearing in the query's ",(0,t.jsx)(n.code,{children:"SELECT"})," list or ",(0,t.jsx)(n.code,{children:"ORDER BY"})," clause. The ",(0,t.jsx)(n.code,{children:"WINDOW"})," clause has the general form:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"WINDOW <window_name> AS ( <window_definition> ) [, ...]\n"})}),"\n",(0,t.jsxs)(n.p,{children:["where ",(0,t.jsx)(n.code,{children:"<window_name>"})," is a name that can be referenced from ",(0,t.jsx)(n.code,{children:"OVER"})," clauses or subsequent window definitions, and ",(0,t.jsx)(n.code,{children:"<window_definition>"})," is:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"[<existing_window_name>]\n[PARTITION BY <expression> [, ...]]\n[ORDER BY <expression> [ASC | DESC | USING <operator>] [NULLS {FIRST | LAST}] [, ...] ]\n[<frame_clause>] \n"})}),"\n",(0,t.jsxs)(n.p,{children:["A ",(0,t.jsx)(n.code,{children:"WINDOW"})," clause entry does not have to be referenced anywhere, however; if it is not used in the query it is simply ignored. It is possible to use window functions without any ",(0,t.jsx)(n.code,{children:"WINDOW"})," clause at all, since a window function call can specify its window definition directly in its ",(0,t.jsx)(n.code,{children:"OVER"})," clause. However, the ",(0,t.jsx)(n.code,{children:"WINDOW"})," clause saves typing when the same window definition is needed for more than one window function."]}),"\n",(0,t.jsx)(n.p,{children:"For example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"SELECT vendor, rank() OVER (mywindow) FROM sale\nGROUP BY vendor\nWINDOW mywindow AS (ORDER BY sum(prc*qty));\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"existing_window_name"})})}),"\n",(0,t.jsxs)(n.p,{children:["If an existing_window_name is specified, it must refer to an earlier entry in the ",(0,t.jsx)(n.code,{children:"WINDOW"})," list; the new window copies its partitioning clause from that entry, as well as its ordering clause if any. The new window cannot specify its own ",(0,t.jsx)(n.code,{children:"PARTITION BY"})," clause, and it can specify ",(0,t.jsx)(n.code,{children:"ORDER BY"})," only if the copied window does not have one. The new window always uses its own frame clause; the copied window must not specify a frame clause."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"PARTITION BY"})})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"PARTITION BY"})," clause organizes the result set into logical groups based on the unique values of the specified expression. The elements of the ",(0,t.jsx)(n.code,{children:"PARTITION BY"})," clause are interpreted in much the same fashion as elements of a ",(0,t.jsx)(n.a,{href:"#groupbyclause",children:"GROUP BY Clause"}),", except that they are always simple expressions and never the name or number of an output column. Another difference is that these expressions can contain aggregate function calls, which are not allowed in a regular ",(0,t.jsx)(n.code,{children:"GROUP BY"})," clause. They are allowed here because windowing occurs after grouping and aggregation. When used with window functions, the functions are applied to each partition independently. For example, if you follow ",(0,t.jsx)(n.code,{children:"PARTITION BY"})," with a column name, the result set is partitioned by the distinct values of that column. If omitted, the entire result set is considered one partition."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"ORDER BY"})})}),"\n",(0,t.jsxs)(n.p,{children:["Similarly, the elements of the ",(0,t.jsx)(n.code,{children:"ORDER BY"})," list are interpreted in much the same fashion as elements of an ",(0,t.jsx)(n.a,{href:"#orderbyclause",children:"ORDER BY Clause"}),", except that the expressions are always taken as simple expressions and never the name or number of an output column."]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Note"})," The elements of the ",(0,t.jsx)(n.code,{children:"ORDER BY"})," clause define how to sort the rows in each partition of the result set. If omitted, rows are returned in whatever order is most efficient and may vary."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"frame_clause"})})}),"\n",(0,t.jsxs)(n.p,{children:["The optional frame_clause defines the ",(0,t.jsx)(n.em,{children:"window frame"})," for window functions that depend on the frame (not all do). The window frame is a set of related rows for each row of the query (called the ",(0,t.jsx)(n.em,{children:"current row"}),"). The frame_clause can be one of"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"{ RANGE | ROWS | GROUPS } <frame_start> [ <frame_exclusion> ]\n{ RANGE | ROWS | GROUPS } BETWEEN <frame_start> AND <frame_end> [ <frame_exclusion> ]\n"})}),"\n",(0,t.jsxs)(n.p,{children:["where ",(0,t.jsx)(n.code,{children:"<frame_start>"})," and ",(0,t.jsx)(n.code,{children:"<frame_end>"})," can be one of"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"UNBOUNDED PRECEDING\n<offset> PRECEDING\nCURRENT ROW\n<offset> FOLLOWING\nUNBOUNDED FOLLOWING\n"})}),"\n",(0,t.jsxs)(n.p,{children:["and ",(0,t.jsx)(n.code,{children:"<frame_exclusion>"})," can be one of"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"EXCLUDE CURRENT ROW\nEXCLUDE GROUP\nEXCLUDE TIES\nEXCLUDE NO OTHERS\n"})}),"\n",(0,t.jsxs)(n.p,{children:["If ",(0,t.jsx)(n.code,{children:"<frame_end>"})," is omitted it defaults to ",(0,t.jsx)(n.code,{children:"CURRENT ROW"}),". Restrictions are that ",(0,t.jsx)(n.code,{children:"<frame_start>"})," cannot be ",(0,t.jsx)(n.code,{children:"UNBOUNDED FOLLOWING"}),", ",(0,t.jsx)(n.code,{children:"<frame_end>"})," cannot be ",(0,t.jsx)(n.code,{children:"UNBOUNDED PRECEDING"}),", and the ",(0,t.jsx)(n.code,{children:"<frame_end>"})," choice cannot appear earlier in the above list of ",(0,t.jsx)(n.code,{children:"<frame_start>"})," and ",(0,t.jsx)(n.code,{children:"<frame_end>"})," options than the ",(0,t.jsx)(n.code,{children:"<frame_start>"})," choice does \u2014 for example ",(0,t.jsx)(n.code,{children:"RANGE BETWEEN CURRENT ROW AND <offset> PRECEDING"})," is not allowed."]}),"\n",(0,t.jsxs)(n.p,{children:["The default framing option is ",(0,t.jsx)(n.code,{children:"RANGE UNBOUNDED PRECEDING"}),", which is the same as ",(0,t.jsx)(n.code,{children:"RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW"}),"; it sets the frame to be all rows from the partition start up through the current row's last peer (a row that the window's ",(0,t.jsx)(n.code,{children:"ORDER BY"})," clause considers equivalent to the current row; all rows are peers if there is no ",(0,t.jsx)(n.code,{children:"ORDER BY"}),"). In general, ",(0,t.jsx)(n.code,{children:"UNBOUNDED PRECEDING"})," means that the frame starts with the first row of the partition, and similarly ",(0,t.jsx)(n.code,{children:"UNBOUNDED FOLLOWING"})," means that the frame ends with the last row of the partition, regardless of ",(0,t.jsx)(n.code,{children:"RANGE"}),", ",(0,t.jsx)(n.code,{children:"ROWS"})," or ",(0,t.jsx)(n.code,{children:"GROUPS"})," mode. In ",(0,t.jsx)(n.code,{children:"ROWS"})," mode, ",(0,t.jsx)(n.code,{children:"CURRENT ROW"})," means that the frame starts or ends with the current row; but in ",(0,t.jsx)(n.code,{children:"RANGE"})," or ",(0,t.jsx)(n.code,{children:"GROUPS"})," mode it means that the frame starts or ends with the current row's first or last peer in the ",(0,t.jsx)(n.code,{children:"ORDER BY"})," ordering. The ",(0,t.jsx)(n.code,{children:"<offset> PRECEDING"})," and ",(0,t.jsx)(n.code,{children:"<offset> FOLLOWING"})," options vary in meaning depending on the frame mode. In ",(0,t.jsx)(n.code,{children:"ROWS"})," mode, the ",(0,t.jsx)(n.code,{children:"<offset>"})," is an integer indicating that the frame starts or ends that many rows before or after the current row."]}),"\n",(0,t.jsxs)(n.p,{children:["In ",(0,t.jsx)(n.code,{children:"GROUPS"})," mode, the ",(0,t.jsx)(n.code,{children:"<offset>"})," is an integer indicating that the frame starts or ends that many peer groups before or after the current row's peer group, where a peer group is a group of rows that are equivalent according to the window's ",(0,t.jsx)(n.code,{children:"ORDER BY"})," clause. In ",(0,t.jsx)(n.code,{children:"RANGE"})," mode, use of an ",(0,t.jsx)(n.code,{children:"<offset>"})," option requires that there be exactly one ",(0,t.jsx)(n.code,{children:"ORDER BY"})," column in the window definition. Then the frame contains those rows whose ordering column value is no more than ",(0,t.jsx)(n.code,{children:"<offset>"})," less than (for ",(0,t.jsx)(n.code,{children:"PRECEDING"}),") or more than (for ",(0,t.jsx)(n.code,{children:"FOLLOWING"}),") the current row's ordering column value. In these cases the data type of the ",(0,t.jsx)(n.code,{children:"<offset>"})," expression depends on the data type of the ordering column. For numeric ordering columns it is typically of the same type as the ordering column, but for datetime ordering columns it is an ",(0,t.jsx)(n.code,{children:"interval"}),". In all these cases, the value of the ",(0,t.jsx)(n.code,{children:"<offset>"})," must be non-null and non-negative. Also, while the offset does not have to be a simple constant, it cannot contain variables, aggregate functions, or window functions."]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"<frame_exclusion>"})," option allows rows around the current row to be excluded from the frame, even if they would be included according to the frame start and frame end options. ",(0,t.jsx)(n.code,{children:"EXCLUDE CURRENT ROW"})," excludes the current row from the frame. ",(0,t.jsx)(n.code,{children:"EXCLUDE GROUP"})," excludes the current row and its ordering peers from the frame. ",(0,t.jsx)(n.code,{children:"EXCLUDE TIES"})," excludes any peers of the current row from the frame, but not the current row itself. ",(0,t.jsx)(n.code,{children:"EXCLUDE NO OTHERS"})," simply specifies explicitly the default behavior of not excluding the current row or its peers."]}),"\n",(0,t.jsxs)(n.p,{children:["Beware that the ",(0,t.jsx)(n.code,{children:"ROWS"})," mode can produce unpredictable results if the ",(0,t.jsx)(n.code,{children:"ORDER BY"})," ordering does not order the rows uniquely. The ",(0,t.jsx)(n.code,{children:"RANGE"})," and ",(0,t.jsx)(n.code,{children:"GROUPS"})," modes are designed to ensure that rows that are peers in the ",(0,t.jsx)(n.code,{children:"ORDER BY"})," ordering are treated alike: all rows of a given peer group will be in the frame or excluded from it."]}),"\n",(0,t.jsxs)(n.p,{children:["Use either a ",(0,t.jsx)(n.code,{children:"ROWS"}),", ",(0,t.jsx)(n.code,{children:"RANGE"}),", or ",(0,t.jsx)(n.code,{children:"GROUPS"})," clause to express the bounds of the window. The window bound can be one, many, or all rows of a partition. You can express the bound of the window either in terms of a range of data values offset from the value in the current row (",(0,t.jsx)(n.code,{children:"RANGE"}),"), in terms of the number of rows offset from the current row (",(0,t.jsx)(n.code,{children:"ROWS"}),"), or in terms of the number of peer groups (",(0,t.jsx)(n.code,{children:"GROUPS"}),"). When using the ",(0,t.jsx)(n.code,{children:"RANGE"})," or the ",(0,t.jsx)(n.code,{children:"GROUPS"})," clause, you must also use an ",(0,t.jsx)(n.code,{children:"ORDER BY"})," clause. This is because the calculation performed to produce the window requires that the values be sorted. Additionally, the ",(0,t.jsx)(n.code,{children:"ORDER BY"})," clause cannot contain more than one expression, and the expression must result in either a date or a numeric value. When using the ",(0,t.jsx)(n.code,{children:"ROWS"}),", ",(0,t.jsx)(n.code,{children:"RANGE"})," or ",(0,t.jsx)(n.code,{children:"GROUPS"})," clauses, if you specify only a starting row, the current row is used as the last row in the window."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"PRECEDING"})," \u2014 The ",(0,t.jsx)(n.code,{children:"PRECEDING"})," clause defines the first row of the window using the current row as a reference point. The starting row is expressed in terms of the number of rows preceding the current row. For example, in the case of ",(0,t.jsx)(n.code,{children:"ROWS"})," framing, ",(0,t.jsx)(n.code,{children:"5 PRECEDING"})," sets the window to start with the fifth row preceding the current row. In the case of ",(0,t.jsx)(n.code,{children:"RANGE"})," framing, it sets the window to start with the first row whose ordering column value precedes that of the current row by 5 in the given order. If the specified order is ascending by date, this will be the first row within 5 days before the current row. ",(0,t.jsx)(n.code,{children:"UNBOUNDED PRECEDING"})," sets the first row in the window to be the first row in the partition."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"BETWEEN"})," \u2014 The ",(0,t.jsx)(n.code,{children:"BETWEEN"})," clause defines the first and last row of the window, using the current row as a reference point. First and last rows are expressed in terms of the number of rows preceding and following the current row, respectively. For example, ",(0,t.jsx)(n.code,{children:"BETWEEN 3 PRECEDING AND 5 FOLLOWING"})," sets the window to start with the third row preceding the current row, and end with the fifth row following the current row. Use ",(0,t.jsx)(n.code,{children:"BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING"})," to set the first and last rows in the window to be the first and last row in the partition, respectively. This is equivalent to the default behavior if no ",(0,t.jsx)(n.code,{children:"ROWs"}),", ",(0,t.jsx)(n.code,{children:"RANGE"})," or ",(0,t.jsx)(n.code,{children:"GROUPS"})," clause is specified."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"FOLLOWING"})," \u2014 The ",(0,t.jsx)(n.code,{children:"FOLLOWING"})," clause defines the last row of the window using the current row as a reference point. The last row is expressed in terms of the number of rows following the current row. For example, in the case of ",(0,t.jsx)(n.code,{children:"ROWS"})," framing, ",(0,t.jsx)(n.code,{children:"5 FOLLOWING"})," sets the window to end with the fifth row following the current row. In the case of ",(0,t.jsx)(n.code,{children:"RANGE"})," framing, it sets the window to end with the last row whose ordering column value follows that of the current row by 5 in the given order. If the specified order is ascending by date, this will be the last row within 5 days after the current row. Use ",(0,t.jsx)(n.code,{children:"UNBOUNDED FOLLOWING"})," to set the last row in the window to be the last row in the partition."]}),"\n",(0,t.jsxs)(n.p,{children:["If you do not specify a ",(0,t.jsx)(n.code,{children:"ROWS"}),", a ",(0,t.jsx)(n.code,{children:"RANGE"})," or a ",(0,t.jsx)(n.code,{children:"GROUPS"})," clause, the window bound starts with the first row in the partition (",(0,t.jsx)(n.code,{children:"UNBOUNDED PRECEDING"}),") and ends with the current row (",(0,t.jsx)(n.code,{children:"CURRENT ROW"}),") if ",(0,t.jsx)(n.code,{children:"ORDER BY"})," is used. If an ",(0,t.jsx)(n.code,{children:"ORDER BY"})," is not specified, the window starts with the first row in the partition (",(0,t.jsx)(n.code,{children:"UNBOUNDED PRECEDING"}),") and ends with last row in the partition (",(0,t.jsx)(n.code,{children:"UNBOUNDED FOLLOWING"}),")."]}),"\n",(0,t.jsxs)(n.p,{children:["The purpose of a ",(0,t.jsx)(n.code,{children:"WINDOW"})," clause is to specify the behavior of window functions appearing in the query's ",(0,t.jsx)(n.a,{href:"#the-select-list",children:"SELECT List"})," or ",(0,t.jsx)(n.a,{href:"#the-order-by-clause",children:"ORDER BY Clause"}),". These functions can reference the ",(0,t.jsx)(n.code,{children:"WINDOW"})," clause entries by name in their ",(0,t.jsx)(n.code,{children:"OVER"})," clauses. A ",(0,t.jsx)(n.code,{children:"WINDOW"})," clause entry does not have to be referenced anywhere, however; if it is not used in the query it is simply ignored. It is possible to use window functions without any ",(0,t.jsx)(n.code,{children:"WINDOW"})," clause at all, since a window function call can specify its window definition directly in its ",(0,t.jsx)(n.code,{children:"OVER"})," clause. However, the ",(0,t.jsx)(n.code,{children:"WINDOW"})," clause saves typing when the same window definition is needed for more than one window function."]}),"\n",(0,t.jsxs)(n.p,{children:["Currently, ",(0,t.jsx)(n.code,{children:"FOR NO KEY UPDATE"}),", ",(0,t.jsx)(n.code,{children:"FOR UPDATE"}),", ",(0,t.jsx)(n.code,{children:"FOR SHARE"}),", and ",(0,t.jsx)(n.code,{children:"FOR KEY SHARE"})," cannot be specified with ",(0,t.jsx)(n.code,{children:"WINDOW"}),"."]}),"\n",(0,t.jsxs)(n.h3,{id:"the-select-list",children:["The ",(0,t.jsx)(n.code,{children:"SELECT"})," list"]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"SELECT"})," list (between the key words ",(0,t.jsx)(n.code,{children:"SELECT"})," and ",(0,t.jsx)(n.code,{children:"FROM"}),") specifies expressions that form the output rows of the ",(0,t.jsx)(n.code,{children:"SELECT"})," statement. The expressions can (and usually do) refer to columns computed in the ",(0,t.jsx)(n.code,{children:"FROM"})," clause."]}),"\n",(0,t.jsxs)(n.p,{children:["An expression in the ",(0,t.jsx)(n.code,{children:"SELECT"})," list can be a constant value, a column reference, an operator invocation, a function call, an aggregate expression, a window expression, a scalar subquery, and so on. A number of constructs can be classified as an expression but do not follow any general syntax rules. These generally have the semantics of a function or operator. For information about SQL value expressions and function calls, see Querying Data in the ",(0,t.jsx)(n.em,{children:"Cloudberry Database Administrator Guide"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Just as in a table, every output column of a ",(0,t.jsx)(n.code,{children:"SELECT"})," has a name. In a simple ",(0,t.jsx)(n.code,{children:"SELECT"})," this name is just used to label the column for display, but when the ",(0,t.jsx)(n.code,{children:"SELECT"})," is a sub-query of a larger query, the name is seen by the larger query as the column name of the virtual table produced by the sub-query. To specify the name to use for an output column, write ",(0,t.jsx)(n.code,{children:"AS <output_name>"})," after the column's expression. (You can omit ",(0,t.jsx)(n.code,{children:"AS"}),", but only if the desired output name does not match any SQL keyword. For protection against possible future keyword additions, you can always either write ",(0,t.jsx)(n.code,{children:"AS"})," or double-quote the output name.) If you do not specify a column name, Cloudberry Database chooses a name automatically. If the column's expression is a simple column reference then the chosen name is the same as that column's name. In more complex cases, a function or type name may be used, or the system may fall back on a generated name such as ",(0,t.jsx)(n.code,{children:"?column?"})," or ",(0,t.jsx)(n.code,{children:"columnN"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["An output column's name can be used to refer to the column's value in ",(0,t.jsx)(n.code,{children:"ORDER BY"})," and ",(0,t.jsx)(n.code,{children:"GROUP BY"})," clauses, but not in the ",(0,t.jsx)(n.code,{children:"WHERE"})," or ",(0,t.jsx)(n.code,{children:"HAVING"})," clauses; there you must specify the expression instead."]}),"\n",(0,t.jsxs)(n.p,{children:["Instead of an expression, you can specify ",(0,t.jsx)(n.code,{children:"*"})," in the output list as a shorthand for all the columns of the selected rows. Also, you can specify ",(0,t.jsx)(n.code,{children:"<table_name>.*"})," as a shorthand for the columns coming from just that table. In these cases it is not possible to specify new names with ",(0,t.jsx)(n.code,{children:"AS"}),"; the output column names will be the same as the table columns' names."]}),"\n",(0,t.jsxs)(n.p,{children:["According to the SQL standard, the expressions in the output list should be computed before applying ",(0,t.jsx)(n.code,{children:"DISTINCT"}),", ",(0,t.jsx)(n.code,{children:"ORDER BY"}),", or ",(0,t.jsx)(n.code,{children:"LIMIT"}),". This is obviously necessary when using ",(0,t.jsx)(n.code,{children:"DISTINCT"}),", since otherwise it's not clear what values are being made distinct. However, in many cases it is convenient if output expressions are computed after ",(0,t.jsx)(n.code,{children:"ORDER BY"})," and ",(0,t.jsx)(n.code,{children:"LIMIT"}),"; particularly if the output list contains any volatile or expensive functions. With that behavior, the order of function evaluations is more intuitive and there will not be evaluations corresponding to rows that never appear in the output. Cloudberry Database effectively evaluates output expressions after sorting and limiting, so long as those expressions are not referenced in ",(0,t.jsx)(n.code,{children:"DISTINCT"}),", ",(0,t.jsx)(n.code,{children:"ORDER BY"}),", or ",(0,t.jsx)(n.code,{children:"GROUP BY"}),". (As a counterexample, ",(0,t.jsx)(n.code,{children:"SELECT f(x) FROM tab ORDER BY 1"})," clearly must evaluate ",(0,t.jsx)(n.code,{children:"f(x)"})," before sorting.) Output expressions that contain set-returning functions are effectively evaluated after sorting and before limiting, so that ",(0,t.jsx)(n.code,{children:"LIMIT"})," will act to cut off the output from a set-returning function."]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Note"})," Cloudberry Database versions prior to 7 did not provide any guarantees about the timing of evaluation of output expressions versus sorting and limiting; it depended on the form of the chosen query plan."]}),"\n"]}),"\n",(0,t.jsxs)(n.h3,{id:"the-distinct-clause",children:["The ",(0,t.jsx)(n.code,{children:"DISTINCT"})," clause"]}),"\n",(0,t.jsxs)(n.p,{children:["If ",(0,t.jsx)(n.code,{children:"SELECT DISTINCT"})," is specified, all duplicate rows are removed from the result set (one row is kept from each group of duplicates). ",(0,t.jsx)(n.code,{children:"SELECT ALL"})," specifies the opposite: all rows are kept; that is the default."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"SELECT DISTINCT ON ( <expression> [, ...] )"})," keeps only the first row of each set of rows where the given expressions evaluate to equal. The ",(0,t.jsx)(n.code,{children:"DISTINCT ON"})," expressions are interpreted using the same rules as for ",(0,t.jsx)(n.code,{children:"ORDER BY"}),' (see above). Note that the "first row" of each set is unpredictable unless ',(0,t.jsx)(n.code,{children:"ORDER BY"})," is used to ensure that the desired row appears first. For example:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"SELECT DISTINCT ON (location) location, time, report\n    FROM weather_reports\n    ORDER BY location, time DESC;\n"})}),"\n",(0,t.jsxs)(n.p,{children:["retrieves the most recent weather report for each location. But if we had not used ",(0,t.jsx)(n.code,{children:"ORDER BY"})," to force descending order of time values for each location, we'd have gotten a report from an unpredictable time for each location."]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"DISTINCT ON"})," expression(s) must match the leftmost ",(0,t.jsx)(n.code,{children:"ORDER BY"})," expression(s). The ",(0,t.jsx)(n.code,{children:"ORDER BY"})," clause will normally contain additional expression(s) that determine the desired precedence of rows within each ",(0,t.jsx)(n.code,{children:"DISTINCT ON"})," group."]}),"\n",(0,t.jsxs)(n.p,{children:["Currently, ",(0,t.jsx)(n.code,{children:"FOR NO KEY UPDATE"}),", ",(0,t.jsx)(n.code,{children:"FOR UPDATE"}),", ",(0,t.jsx)(n.code,{children:"FOR SHARE"}),", and ",(0,t.jsx)(n.code,{children:"FOR KEY SHARE"})," cannot be specified with ",(0,t.jsx)(n.code,{children:"DISTINCT"}),"."]}),"\n",(0,t.jsxs)(n.h3,{id:"the-union-clause",children:["The ",(0,t.jsx)(n.code,{children:"UNION"})," clause"]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"UNION"})," clause has this general form:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"<select_statement> UNION [ALL | DISTINCT] <select_statement>\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"<select_statement>"})," is any ",(0,t.jsx)(n.code,{children:"SELECT"})," statement without an ",(0,t.jsx)(n.code,{children:"ORDER BY"}),", ",(0,t.jsx)(n.code,{children:"LIMIT"}),", ",(0,t.jsx)(n.code,{children:"FOR NO KEY UPDATE"}),", ",(0,t.jsx)(n.code,{children:"FOR UPDATE"}),", ",(0,t.jsx)(n.code,{children:"FOR SHARE"}),", or ",(0,t.jsx)(n.code,{children:"FOR KEY SHARE"})," clause. (",(0,t.jsx)(n.code,{children:"ORDER BY"})," and ",(0,t.jsx)(n.code,{children:"LIMIT"})," can be attached to a subquery expression if it is enclosed in parentheses. Without parentheses, these clauses will be taken to apply to the result of the ",(0,t.jsx)(n.code,{children:"UNION"}),", not to its right-hand input expression.)"]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"UNION"})," operator computes the set union of the rows returned by the involved ",(0,t.jsx)(n.code,{children:"SELECT"})," statements. A row is in the set union of two result sets if it appears in at least one of the result sets. The two ",(0,t.jsx)(n.code,{children:"SELECT"})," statements that represent the direct operands of the ",(0,t.jsx)(n.code,{children:"UNION"})," must produce the same number of columns, and corresponding columns must be of compatible data types."]}),"\n",(0,t.jsxs)(n.p,{children:["The result of ",(0,t.jsx)(n.code,{children:"UNION"})," does not contain any duplicate rows unless the ",(0,t.jsx)(n.code,{children:"ALL"})," option is specified. ",(0,t.jsx)(n.code,{children:"ALL"})," prevents elimination of duplicates. (Therefore, ",(0,t.jsx)(n.code,{children:"UNION ALL"})," is usually significantly quicker than ",(0,t.jsx)(n.code,{children:"UNION"}),"; use ",(0,t.jsx)(n.code,{children:"ALL"})," when you can.) ",(0,t.jsx)(n.code,{children:"DISTINCT"})," can be specified to explicitly specify the default behavior of eliminating duplicate rows."]}),"\n",(0,t.jsxs)(n.p,{children:["Multiple ",(0,t.jsx)(n.code,{children:"UNION"})," operators in the same ",(0,t.jsx)(n.code,{children:"SELECT"})," statement are evaluated left to right, unless otherwise indicated by parentheses."]}),"\n",(0,t.jsxs)(n.p,{children:["Currently, ",(0,t.jsx)(n.code,{children:"FOR NO KEY UPDATE"}),", ",(0,t.jsx)(n.code,{children:"FOR UPDATE"}),", ",(0,t.jsx)(n.code,{children:"FOR SHARE"}),", and ",(0,t.jsx)(n.code,{children:"FOR KEY SHARE"})," cannot be specified either for a ",(0,t.jsx)(n.code,{children:"UNION"})," result or for any input of a ",(0,t.jsx)(n.code,{children:"UNION"}),"."]}),"\n",(0,t.jsxs)(n.h3,{id:"the-intersect-clause",children:["The ",(0,t.jsx)(n.code,{children:"INTERSECT"})," clause"]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"INTERSECT"})," clause has this general form:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"<select_statement> INTERSECT [ALL | DISTINCT] <select_statement>\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"<select_statement>"})," is any ",(0,t.jsx)(n.code,{children:"SELECT"})," statement without an ",(0,t.jsx)(n.code,{children:"ORDER BY"}),", ",(0,t.jsx)(n.code,{children:"LIMIT"}),", ",(0,t.jsx)(n.code,{children:"FOR NO KEY UPDATE"}),", ",(0,t.jsx)(n.code,{children:"FOR UPDATE"}),", ",(0,t.jsx)(n.code,{children:"FOR SHARE"}),", or ",(0,t.jsx)(n.code,{children:"FOR KEY SHARE"})," clause."]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"INTERSECT"})," operator computes the set intersection of the rows returned by the involved ",(0,t.jsx)(n.code,{children:"SELECT"})," statements. A row is in the intersection of two result sets if it appears in both result sets."]}),"\n",(0,t.jsxs)(n.p,{children:["The result of ",(0,t.jsx)(n.code,{children:"INTERSECT"})," does not contain any duplicate rows unless the ",(0,t.jsx)(n.code,{children:"ALL"})," option is specified. With ",(0,t.jsx)(n.code,{children:"ALL"}),", a row that has ",(0,t.jsx)(n.code,{children:"<m>"})," duplicates in the left table and ",(0,t.jsx)(n.code,{children:"<n>"})," duplicates in the right table will appear ",(0,t.jsx)(n.code,{children:"min(<m>, <n>)"})," times in the result set. ",(0,t.jsx)(n.code,{children:"DISTINCT"})," can be written to explicitly specify the default behavior of eliminating duplicate rows."]}),"\n",(0,t.jsxs)(n.p,{children:["Multiple ",(0,t.jsx)(n.code,{children:"INTERSECT"})," operators in the same ",(0,t.jsx)(n.code,{children:"SELECT"})," statement are evaluated left to right, unless parentheses dictate otherwise. ",(0,t.jsx)(n.code,{children:"INTERSECT"})," binds more tightly than ",(0,t.jsx)(n.code,{children:"UNION"}),". That is, ",(0,t.jsx)(n.code,{children:"A UNION B INTERSECT C"})," will be read as ",(0,t.jsx)(n.code,{children:"A UNION (B INTERSECT C)"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Currently, ",(0,t.jsx)(n.code,{children:"FOR NO KEY UPDATE"}),", ",(0,t.jsx)(n.code,{children:"FOR UPDATE"}),", ",(0,t.jsx)(n.code,{children:"FOR SHARE"}),", and ",(0,t.jsx)(n.code,{children:"FOR KEY SHARE"})," cannot be specified either for an ",(0,t.jsx)(n.code,{children:"INTERSECT"})," result or for any input of an ",(0,t.jsx)(n.code,{children:"INTERSECT"}),"."]}),"\n",(0,t.jsxs)(n.h3,{id:"the-except-clause",children:["The ",(0,t.jsx)(n.code,{children:"EXCEPT"})," clause"]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"EXCEPT"})," clause has this general form:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"<select_statement> EXCEPT [ALL | DISTINCT] <select_statement>\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"<select_statement>"})," is any ",(0,t.jsx)(n.code,{children:"SELECT"})," statement without an ",(0,t.jsx)(n.code,{children:"ORDER BY"}),", ",(0,t.jsx)(n.code,{children:"LIMIT"}),", ",(0,t.jsx)(n.code,{children:"FOR NO KEY UPDATE"}),", ",(0,t.jsx)(n.code,{children:"FOR UPDATE"}),", ",(0,t.jsx)(n.code,{children:"FOR SHARE"}),", or ",(0,t.jsx)(n.code,{children:"FOR KEY SHARE"})," clause."]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"EXCEPT"})," operator computes the set of rows that are in the result of the left ",(0,t.jsx)(n.code,{children:"SELECT"})," statement but not in the result of the right one."]}),"\n",(0,t.jsxs)(n.p,{children:["The result of ",(0,t.jsx)(n.code,{children:"EXCEPT"})," does not contain any duplicate rows unless the ",(0,t.jsx)(n.code,{children:"ALL"})," option is specified. With ",(0,t.jsx)(n.code,{children:"ALL"}),", a row that has ",(0,t.jsx)(n.code,{children:"<m>"})," duplicates in the left table and ",(0,t.jsx)(n.code,{children:"<n>"})," duplicates in the right table will appear ",(0,t.jsx)(n.code,{children:"max(<m>-<n>,0)"})," times in the result set. ",(0,t.jsx)(n.code,{children:"DISTINCT"})," can be written to explicitly specify the default behavior of eliminating duplicate rows."]}),"\n",(0,t.jsxs)(n.p,{children:["Multiple ",(0,t.jsx)(n.code,{children:"EXCEPT"})," operators in the same ",(0,t.jsx)(n.code,{children:"SELECT"})," statement are evaluated left to right, unless parentheses dictate otherwise. ",(0,t.jsx)(n.code,{children:"EXCEPT"})," binds at the same level as ",(0,t.jsx)(n.code,{children:"UNION"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Currently, ",(0,t.jsx)(n.code,{children:"FOR NO KEY UPDATE"}),", ",(0,t.jsx)(n.code,{children:"FOR UPDATE"}),", ",(0,t.jsx)(n.code,{children:"FOR SHARE"}),", and ",(0,t.jsx)(n.code,{children:"FOR KEY SHARE"})," cannot be specified either for an ",(0,t.jsx)(n.code,{children:"EXCEPT"})," result or for any input of an ",(0,t.jsx)(n.code,{children:"EXCEPT"}),"."]}),"\n",(0,t.jsxs)(n.h3,{id:"the-order-by-clause",children:["The ",(0,t.jsx)(n.code,{children:"ORDER BY"})," clause"]}),"\n",(0,t.jsxs)(n.p,{children:["The optional ",(0,t.jsx)(n.code,{children:"ORDER BY"})," clause has this general form:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"ORDER BY <expression> [ASC | DESC | USING <operator>] [NULLS {FIRST | LAST}] [,...]\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"ORDER BY"})," clause causes the result rows to be sorted according to the specified expression(s). If two rows are equal according to the left-most expression, they are compared according to the next expression and so on. If they are equal according to all specified expressions, they are returned in an implementation-dependent order."]}),"\n",(0,t.jsxs)(n.p,{children:["Each ",(0,t.jsx)(n.code,{children:"<expression>"})," can be the name or ordinal number of an output column (",(0,t.jsx)(n.code,{children:"SELECT"})," list item), or it can be an arbitrary expression formed from input-column values."]}),"\n",(0,t.jsxs)(n.p,{children:["The ordinal number refers to the ordinal (left-to-right) position of the output column. This feature makes it possible to define an ordering on the basis of a column that does not have a unique name. This is never absolutely necessary because it is always possible to assign a name to an output column using the ",(0,t.jsx)(n.code,{children:"AS"})," clause."]}),"\n",(0,t.jsxs)(n.p,{children:["It is also possible to use arbitrary expressions in the ",(0,t.jsx)(n.code,{children:"ORDER BY"})," clause, including columns that do not appear in the ",(0,t.jsx)(n.code,{children:"SELECT"})," output list. Thus the following statement is valid:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"SELECT name FROM distributors ORDER BY code;\n"})}),"\n",(0,t.jsxs)(n.p,{children:["A limitation of this feature is that an ",(0,t.jsx)(n.code,{children:"ORDER BY"})," clause applying to the result of a ",(0,t.jsx)(n.code,{children:"UNION"}),", ",(0,t.jsx)(n.code,{children:"INTERSECT"}),", or ",(0,t.jsx)(n.code,{children:"EXCEPT"})," clause may only specify an output column name or number, not an expression."]}),"\n",(0,t.jsxs)(n.p,{children:["If an ",(0,t.jsx)(n.code,{children:"ORDER BY"})," expression is a simple name that matches both an output column name and an input column name, ",(0,t.jsx)(n.code,{children:"ORDER BY"})," will interpret it as the output column name. This is the opposite of the choice that ",(0,t.jsx)(n.code,{children:"GROUP BY"})," will make in the same situation. This inconsistency is made to be compatible with the SQL standard."]}),"\n",(0,t.jsxs)(n.p,{children:["Optionally one may add the key word ",(0,t.jsx)(n.code,{children:"ASC"})," (ascending) or ",(0,t.jsx)(n.code,{children:"DESC"})," (descending) after any expression in the ",(0,t.jsx)(n.code,{children:"ORDER BY"})," clause. If not specified, ",(0,t.jsx)(n.code,{children:"ASC"})," is assumed by default. Alternatively, a specific ordering operator name may be specified in the ",(0,t.jsx)(n.code,{children:"USING"})," clause. ",(0,t.jsx)(n.code,{children:"ASC"})," is usually equivalent to ",(0,t.jsx)(n.code,{children:"USING <"})," and ",(0,t.jsx)(n.code,{children:"DESC"})," is usually equivalent to ",(0,t.jsx)(n.code,{children:"USING >"}),". (But the creator of a user-defined data type can define exactly what the default sort ordering is, and it might correspond to operators with other names.)"]}),"\n",(0,t.jsxs)(n.p,{children:["If ",(0,t.jsx)(n.code,{children:"NULLS LAST"})," is specified, null values sort after all non-null values; if ",(0,t.jsx)(n.code,{children:"NULLS FIRST"})," is specified, null values sort before all non-null values. If neither is specified, the default behavior is ",(0,t.jsx)(n.code,{children:"NULLS LAST"})," when ",(0,t.jsx)(n.code,{children:"ASC"})," is specified or implied, and ",(0,t.jsx)(n.code,{children:"NULLS FIRST"})," when ",(0,t.jsx)(n.code,{children:"DESC"})," is specified (thus, the default is to act as though nulls are larger than non-nulls). When ",(0,t.jsx)(n.code,{children:"USING"})," is specified, the default nulls ordering depends upon whether the operator is a less-than or greater-than operator."]}),"\n",(0,t.jsxs)(n.p,{children:["Note that ordering options apply only to the expression they follow; for example ",(0,t.jsx)(n.code,{children:"ORDER BY x, y DESC"})," does not mean the same thing as ",(0,t.jsx)(n.code,{children:"ORDER BY x DESC, y DESC"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Character-string data is sorted according to the locale-specific collation order that was established when the database was created. You can override this at need by including a ",(0,t.jsx)(n.code,{children:"COLLATE"})," clause in the expression, for example ",(0,t.jsx)(n.code,{children:'ORDER BY mycolumn COLLATE "en_US"'}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Character-string data is sorted according to the collation that applies to the column being sorted. That can be overridden as needed by including a ",(0,t.jsx)(n.code,{children:"COLLATE"})," clause in the expression, for example ",(0,t.jsx)(n.code,{children:'ORDER BY mycolumn COLLATE "en_US"'}),". For information about defining collations, see ",(0,t.jsx)(n.a,{href:"/docs/sql-stmts/create-collation",children:"CREATE COLLATION"}),"."]}),"\n",(0,t.jsxs)(n.h3,{id:"the-limit-clause",children:["The ",(0,t.jsx)(n.code,{children:"LIMIT"})," clause"]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"LIMIT"})," clause consists of two independent sub-clauses:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"LIMIT {<count> | ALL}\nOFFSET <start>\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"<count>"})," specifies the maximum number of rows to return, while ",(0,t.jsx)(n.code,{children:"<start>"})," specifies the number of rows to skip before starting to return rows. When both are specified, ",(0,t.jsx)(n.code,{children:"<start>"})," rows are skipped before starting to count the ",(0,t.jsx)(n.code,{children:"<count>"})," rows to be returned."]}),"\n",(0,t.jsxs)(n.p,{children:["If the ",(0,t.jsx)(n.code,{children:"<count>"})," expression evaluates to NULL, it is treated as ",(0,t.jsx)(n.code,{children:"LIMIT ALL"}),", that is, no limit. If ",(0,t.jsx)(n.code,{children:"<start>"})," evaluates to NULL, it is treated the same as ",(0,t.jsx)(n.code,{children:"OFFSET 0"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"SQL:2008 introduced a different syntax to achieve the same result, which Cloudberry Database also supports. It is:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"OFFSET <start> [ ROW | ROWS ]\n    FETCH { FIRST | NEXT } [ <count> ] { ROW | ROWS } ONLY\n"})}),"\n",(0,t.jsxs)(n.p,{children:["In this syntax, the ",(0,t.jsx)(n.code,{children:"<start>"})," or ",(0,t.jsx)(n.code,{children:"<count>"})," value is required by the standard to be a literal constant, a parameter, or a variable name; as a Cloudberry Database extension, other expressions are allowed, but will generally need to be enclosed in parentheses to avoid ambiguity. If ",(0,t.jsx)(n.code,{children:"<count>"})," is omitted in a ",(0,t.jsx)(n.code,{children:"FETCH"})," clause, it defaults to 1. ",(0,t.jsx)(n.code,{children:"ROW"})," and ",(0,t.jsx)(n.code,{children:"ROWS"})," as well as ",(0,t.jsx)(n.code,{children:"FIRST"})," and ",(0,t.jsx)(n.code,{children:"NEXT"})," are noise words that don't influence the effects of these clauses. According to the standard, the ",(0,t.jsx)(n.code,{children:"OFFSET"})," clause must come before the ",(0,t.jsx)(n.code,{children:"FETCH"})," clause if both are present; but Cloudberry Database allows either order."]}),"\n",(0,t.jsxs)(n.p,{children:["When using ",(0,t.jsx)(n.code,{children:"LIMIT"}),", it is a good idea to use an ",(0,t.jsx)(n.code,{children:"ORDER BY"})," clause that constrains the result rows into a unique order. Otherwise you will get an unpredictable subset of the query's rows \u2014 you may be asking for the tenth through twentieth rows, but tenth through twentieth in what ordering? You don't know what ordering unless you specify ",(0,t.jsx)(n.code,{children:"ORDER BY"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["The query optimizer takes ",(0,t.jsx)(n.code,{children:"LIMIT"})," into account when generating a query plan, so you are very likely to get different plans (yielding different row orders) depending on what you use for ",(0,t.jsx)(n.code,{children:"LIMIT"})," and ",(0,t.jsx)(n.code,{children:"OFFSET"}),". Thus, using different ",(0,t.jsx)(n.code,{children:"LIMIT/OFFSET"})," values to select different subsets of a query result will give inconsistent results unless you enforce a predictable result ordering with ",(0,t.jsx)(n.code,{children:"ORDER BY"}),". This is not a defect; it is an inherent consequence of the fact that SQL does not promise to deliver the results of a query in any particular order unless ",(0,t.jsx)(n.code,{children:"ORDER BY"})," is used to constrain the order."]}),"\n",(0,t.jsxs)(n.p,{children:["It is even possible for repeated executions of the same ",(0,t.jsx)(n.code,{children:"LIMIT"})," query to return different subsets of the rows of a table, if there is not an ",(0,t.jsx)(n.code,{children:"ORDER BY"})," to enforce selection of a deterministic subset. Again, this is not a bug; Cloudberry Database does not guarantee determinism of the results in such a case."]}),"\n",(0,t.jsxs)(n.h3,{id:"the-locking-clause",children:["The ",(0,t.jsx)(n.code,{children:"LOCKING"})," clause"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"FOR UPDATE"}),", ",(0,t.jsx)(n.code,{children:"FOR NO KEY UPDATE"}),", ",(0,t.jsx)(n.code,{children:"FOR SHARE"}),", and ",(0,t.jsx)(n.code,{children:"FOR KEY SHARE"})," are ",(0,t.jsx)(n.em,{children:"locking clauses"}),"; they affect how ",(0,t.jsx)(n.code,{children:"SELECT"})," locks rows as they are obtained from the table. The Global Deadlock Detector affects the locking used by ",(0,t.jsx)(n.code,{children:"SELECT"})," queries that contain a locking clause (",(0,t.jsx)(n.code,{children:"FOR <lock_strength>"}),"). The Global Deadlock Detector is enabled by setting the gp_enable_global_deadlock_detector configuration parameter to ",(0,t.jsx)(n.code,{children:"on"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"The locking clause has the general form:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"FOR <lock_strength> [OF <table_name> [ , ... ] ] [ NOWAIT | SKIP LOCKED ] \n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"<lock_strength>"})," can be one of these values:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"UPDATE"})," - Locks the table with an ",(0,t.jsx)(n.code,{children:"EXCLUSIVE"})," lock."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"NO KEY UPDATE"})," - Locks the table with an ",(0,t.jsx)(n.code,{children:"EXCLUSIVE"})," lock."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"SHARE"})," - Locks the table with a ",(0,t.jsx)(n.code,{children:"ROW SHARE"})," lock."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"KEY SHARE"})," - Locks the table with a ",(0,t.jsx)(n.code,{children:"ROW SHARE"})," lock."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"When the Global Deadlock Detector is deactivated (the default), Cloudberry Database uses the specified lock."}),"\n",(0,t.jsxs)(n.p,{children:["When the Global Deadlock Detector is enabled, a ",(0,t.jsx)(n.code,{children:"ROW SHARE"})," lock is used to lock the table for simple ",(0,t.jsx)(n.code,{children:"SELECT"})," queries that contain a locking clause, and the query plans contain a ",(0,t.jsx)(n.code,{children:"lockrows"})," node. Simple ",(0,t.jsx)(n.code,{children:"SELECT"})," queries that contain a locking clause fulfill all the following conditions:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The locking clause is in the top level ",(0,t.jsx)(n.code,{children:"SELECT"})," context."]}),"\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"FROM"})," clause contains a single table that is not a view or an append optimized table."]}),"\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"SELECT"})," command does not contain a set operation such as ",(0,t.jsx)(n.code,{children:"UNION"})," or ",(0,t.jsx)(n.code,{children:"INTERSECT"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"SELECT"})," command does not contain a sub-query."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Otherwise, table locking for a ",(0,t.jsx)(n.code,{children:"SELECT"})," query that contains a locking clause behaves as if the Global Deadlock Detector is deactivated."]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Note"})," The Global Deadlock Detector also affects the locking used by ",(0,t.jsx)(n.code,{children:"DELETE"})," and ",(0,t.jsx)(n.code,{children:"UPDATE"})," operations. By default, Cloudberry Database acquires an ",(0,t.jsx)(n.code,{children:"EXCLUSIVE"})," lock on tables for ",(0,t.jsx)(n.code,{children:"DELETE"})," and ",(0,t.jsx)(n.code,{children:"UPDATE"})," operations on heap tables. When the Global Deadlock Detector is enabled, the lock mode for ",(0,t.jsx)(n.code,{children:"DELETE"})," and ",(0,t.jsx)(n.code,{children:"UPDATE"})," operations on heap tables is ",(0,t.jsx)(n.code,{children:"ROW EXCLUSIVE"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["For more information on each row-level lock mode, refer to ",(0,t.jsx)(n.a,{href:"https://www.postgresql.org/docs/12/explicit-locking.html",children:"Explicit Locking"})," in the PostgreSQL documentation."]}),"\n",(0,t.jsxs)(n.p,{children:["To prevent the operation from waiting for other transactions to commit, use either the ",(0,t.jsx)(n.code,{children:"NOWAIT"})," option or the ",(0,t.jsx)(n.code,{children:"SKIP LOCKED"})," option. With ",(0,t.jsx)(n.code,{children:"NOWAIT"}),", the statement reports an error, rather than waiting, if a selected row cannot be locked immediately. With ",(0,t.jsx)(n.code,{children:"SKIP LOCKED"}),", any selected rows that cannot be immediately locked are skipped. Skipping locked rows provides an inconsistent view of the data, so this is not suitable for general purpose work, but can be used to avoid lock contention with multiple consumers accessing a queue-like table. Note that ",(0,t.jsx)(n.code,{children:"NOWAIT"})," and ",(0,t.jsx)(n.code,{children:"SKIP LOCKED"})," apply only to the row-level lock(s) \u2014 the required ",(0,t.jsx)(n.code,{children:"ROW SHARE"})," table-level lock is still taken in the ordinary way. You can use ",(0,t.jsx)(n.a,{href:"/docs/sql-stmts/lock",children:"LOCK"})," with the ",(0,t.jsx)(n.code,{children:"NOWAIT"})," option first, if you need to acquire the table-level lock without waiting."]}),"\n",(0,t.jsxs)(n.p,{children:["If specific tables are named in a locking clause, then only rows coming from those tables are locked; any other tables used in the ",(0,t.jsx)(n.code,{children:"SELECT"})," are simply read as usual. A locking clause without a table list affects all tables used in the statement. If a locking clause is applied to a view or sub-query, it affects all tables used in the view or sub-query. However, these clauses do not apply to ",(0,t.jsx)(n.code,{children:"WITH"})," queries referenced by the primary query. If you want row locking to occur within a ",(0,t.jsx)(n.code,{children:"WITH"})," query, specify a locking clause within the ",(0,t.jsx)(n.code,{children:"WITH"})," query."]}),"\n",(0,t.jsxs)(n.p,{children:["Multiple locking clauses can be written if it is necessary to specify different locking behavior for different tables. If the same table is mentioned (or implicitly affected) by both more than one locking clause, then it is processed as if it was only specified by the strongest one. Similarly, a table is processed as ",(0,t.jsx)(n.code,{children:"NOWAIT"})," if that is specified in any of the clauses affecting it. Otherwise, it is processed as ",(0,t.jsx)(n.code,{children:"SKIP LOCKED"})," if that is specified in any of the clauses affecting it."]}),"\n",(0,t.jsx)(n.p,{children:"The locking clauses cannot be used in contexts where returned rows cannot be clearly identified with individual table rows; for example they cannot be used with aggregation."}),"\n",(0,t.jsxs)(n.p,{children:["When a locking clause appears at the top level of a ",(0,t.jsx)(n.code,{children:"SELECT"})," query, the rows that are locked are exactly those that are returned by the query; in the case of a join query, the rows locked are those that contribute to returned join rows. In addition, rows that satisfied the query conditions as of the query snapshot will be locked, although they will not be returned if they were updated after the snapshot and no longer satisfy the query conditions. If a ",(0,t.jsx)(n.code,{children:"LIMIT"})," is used, locking stops once enough rows have been returned to satisfy the limit (but note that rows skipped over by ",(0,t.jsx)(n.code,{children:"OFFSET"})," will get locked). Similarly, if a locking clause is used in a cursor's query, only rows actually fetched or stepped past by the cursor will be locked."]}),"\n",(0,t.jsxs)(n.p,{children:["When a locking clause appears in a sub-",(0,t.jsx)(n.code,{children:"SELECT"}),", the rows locked are those returned to the outer query by the sub-query. This might involve fewer rows than inspection of the sub-query alone would suggest, since conditions from the outer query might be used to optimize execution of the sub-query. For example,"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"SELECT * FROM (SELECT * FROM mytable FOR UPDATE) ss WHERE col1 = 5;\n"})}),"\n",(0,t.jsxs)(n.p,{children:["will lock only rows having ",(0,t.jsx)(n.code,{children:"col1 = 5"}),", even though that condition is not textually within the sub-query."]}),"\n",(0,t.jsxs)(n.p,{children:["It is possible for a ",(0,t.jsx)(n.code,{children:"SELECT"})," command running at the ",(0,t.jsx)(n.code,{children:"READ COMMITTED"})," transaction isolation level and using ",(0,t.jsx)(n.code,{children:"ORDER BY"})," and a locking clause to return rows out of order. This is because ",(0,t.jsx)(n.code,{children:"ORDER BY"})," is applied first. The command sorts the result, but might then block trying to obtain a lock on one or more of the rows. Once the ",(0,t.jsx)(n.code,{children:"SELECT"})," unblocks, some of the ordering column values might have been modified, leading to those rows appearing to be out of order (though they are in order in terms of the original column values). This can be worked around at need by placing the ",(0,t.jsx)(n.code,{children:"FOR UPDATE/SHARE"})," clause in a sub-query, for example"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"SELECT * FROM (SELECT * FROM mytable FOR UPDATE) ss ORDER BY column1;\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Note that this will result in locking all rows of ",(0,t.jsx)(n.code,{children:"mytable"}),", whereas ",(0,t.jsx)(n.code,{children:"FOR UPDATE"})," at the top level would lock only the actually returned rows. This can make for a significant performance difference, particularly if the ",(0,t.jsx)(n.code,{children:"ORDER BY"})," is combined with ",(0,t.jsx)(n.code,{children:"LIMIT"})," or other restrictions. So this technique is recommended only if concurrent updates of the ordering columns are expected and a strictly sorted result is required."]}),"\n",(0,t.jsxs)(n.p,{children:["At the ",(0,t.jsx)(n.code,{children:"REPEATABLE READ"})," or ",(0,t.jsx)(n.code,{children:"SERIALIZABLE"})," transaction isolation level this would cause a serialization failure (with a ",(0,t.jsx)(n.code,{children:"SQLSTATE"})," of ",(0,t.jsx)(n.code,{children:"40001"}),"), so there is no possibility of receiving rows out of order under these isolation levels."]}),"\n",(0,t.jsx)(n.h2,{id:"the-table-command",children:"The table command"}),"\n",(0,t.jsx)(n.p,{children:"The command"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"TABLE <name>\n"})}),"\n",(0,t.jsx)(n.p,{children:"is equivalent to"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"SELECT * FROM <name>\n"})}),"\n",(0,t.jsxs)(n.p,{children:["It can be used as a top-level command or as a space-saving syntax variant in parts of complex queries. Only the ",(0,t.jsx)(n.code,{children:"WITH"}),", ",(0,t.jsx)(n.code,{children:"UNION"}),", ",(0,t.jsx)(n.code,{children:"INTERSECT"}),", ",(0,t.jsx)(n.code,{children:"EXCEPT"}),", ",(0,t.jsx)(n.code,{children:"ORDER BY"}),", ",(0,t.jsx)(n.code,{children:"LIMIT"}),", ",(0,t.jsx)(n.code,{children:"OFFSET"}),", ",(0,t.jsx)(n.code,{children:"FETCH"}),", and ",(0,t.jsx)(n.code,{children:"FOR"})," locking clauses can be used with ",(0,t.jsx)(n.code,{children:"TABLE"}),"; the ",(0,t.jsx)(n.code,{children:"WHERE"})," clause and any form of aggregation cannot be used."]}),"\n",(0,t.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,t.jsxs)(n.p,{children:["To join the table ",(0,t.jsx)(n.code,{children:"films"})," with the table ",(0,t.jsx)(n.code,{children:"distributors"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"SELECT f.title, f.did, d.name, f.date_prod, f.kind\n  FROM distributors d, JOIN films f USING (did);\n"})}),"\n",(0,t.jsxs)(n.p,{children:["To sum the column ",(0,t.jsx)(n.code,{children:"length"})," of all films and group the results by ",(0,t.jsx)(n.code,{children:"kind"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"SELECT kind, sum(length) AS total FROM films GROUP BY kind;\n"})}),"\n",(0,t.jsxs)(n.p,{children:["To sum the column ",(0,t.jsx)(n.code,{children:"length"})," of all films, group the results by ",(0,t.jsx)(n.code,{children:"kind"}),", and show those group totals that are less than 5 hours:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"SELECT kind, sum(length) AS total FROM films GROUP BY kind \n  HAVING sum(length) < interval '5 hours';\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Calculate the subtotals and grand totals of all sales for movie ",(0,t.jsx)(n.code,{children:"kind"})," and ",(0,t.jsx)(n.code,{children:"distributor"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"SELECT kind, distributor, sum(prc*qty) FROM sales\nGROUP BY ROLLUP(kind, distributor)\nORDER BY 1,2,3;\n"})}),"\n",(0,t.jsx)(n.p,{children:"Calculate the rank of movie distributors based on total sales:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"SELECT distributor, sum(prc*qty), \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0rank() OVER (ORDER BY sum(prc*qty) DESC) \nFROM sales\nGROUP BY distributor ORDER BY 2 DESC;\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The following two examples are identical ways of sorting the individual results according to the contents of the second column (",(0,t.jsx)(n.code,{children:"name"}),"):"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"SELECT * FROM distributors ORDER BY name;\nSELECT * FROM distributors ORDER BY 2;\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The next example shows how to obtain the union of the tables ",(0,t.jsx)(n.code,{children:"distributors"})," and ",(0,t.jsx)(n.code,{children:"actors"}),", restricting the results to those that begin with the letter ",(0,t.jsx)(n.code,{children:"W"})," in each table. Only distinct rows are wanted, so the key word ",(0,t.jsx)(n.code,{children:"ALL"})," is omitted:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"SELECT distributors.name\n  FROM distributors\n  WHERE distributors.name LIKE 'W%'\nUNION\nSELECT actors.name\n  FROM actors\n  WHERE actors.name LIKE 'W%';\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This example shows how to use a function in the ",(0,t.jsx)(n.code,{children:"FROM"})," clause, both with and without a column definition list:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"CREATE FUNCTION distributors(int) RETURNS SETOF distributors \nAS $$ SELECT * FROM distributors WHERE did = $1; $$ LANGUAGE \nSQL;\nSELECT * FROM distributors(111);\n\nCREATE FUNCTION distributors_2(int) RETURNS SETOF record AS \n$$ SELECT * FROM distributors WHERE did = $1; $$ LANGUAGE \nSQL;\nSELECT * FROM distributors_2(111) AS (dist_id int, dist_name text);\n"})}),"\n",(0,t.jsx)(n.p,{children:"This example uses a function with an ordinality column added:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"SELECT * FROM unnest(ARRAY['a','b','c','d','e','f']) WITH ORDINALITY;\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This example uses a simple ",(0,t.jsx)(n.code,{children:"WITH"})," clause:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"WITH test AS (\n  SELECT random() as x FROM generate_series(1, 3)\n  )\nSELECT * FROM test\nUNION ALL\nSELECT * FROM test; \n"})}),"\n",(0,t.jsxs)(n.p,{children:["This example uses the ",(0,t.jsx)(n.code,{children:"WITH"})," clause to display per-product sales totals in only the top sales regions."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"WITH regional_sales AS \n    SELECT region, SUM(amount) AS total_sales\n    FROM orders\n    GROUP BY region\n  ), top_regions AS (\n    SELECT region\n    FROM regional_sales\n    WHERE total_sales > (SELECT SUM(total_sales) FROM\n       regional_sales)\n  )\nSELECT region, product, SUM(quantity) AS product_units,\n   SUM(amount) AS product_sales\nFROM orders\nWHERE region IN (SELECT region FROM top_regions) \nGROUP BY region, product;\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The example could have been written without the ",(0,t.jsx)(n.code,{children:"WITH"})," clause but would have required two levels of nested sub-",(0,t.jsx)(n.code,{children:"SELECT"})," statements."]}),"\n",(0,t.jsxs)(n.p,{children:["This example uses the ",(0,t.jsx)(n.code,{children:"WITH RECURSIVE"})," clause to find all subordinates (direct or indirect) of the employee Mary, and their level of indirectness, from a table that shows only direct subordinates:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"WITH RECURSIVE employee_recursive(distance, employee_name, manager_name) AS (\n    SELECT 1, employee_name, manager_name\n    FROM employee\n    WHERE manager_name = 'Mary'\n  UNION ALL\n    SELECT er.distance + 1, e.employee_name, e.manager_name\n    FROM employee_recursive er, employee e\n    WHERE er.employee_name = e.manager_name\n  )\nSELECT distance, employee_name FROM employee_recursive;\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The typical form of a recursive query is an initial condition, followed by ",(0,t.jsx)(n.code,{children:"UNION [ALL]"}),", followed by the recursive part of the query. Be sure that the recursive part of the query will eventually return no tuples, or else the query will loop indefinitely."]}),"\n",(0,t.jsxs)(n.p,{children:["This example uses ",(0,t.jsx)(n.code,{children:"LATERAL"})," to apply a set-returning function ",(0,t.jsx)(n.code,{children:"get_product_names()"})," for each row of the ",(0,t.jsx)(n.code,{children:"manufacturers"})," table:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"SELECT m.name AS mname, pname\n  FROM manufacturers m, LATERAL get_product_names(m.id) pname;\n"})}),"\n",(0,t.jsx)(n.p,{children:"Manufacturers not currently having any products would not appear in the result, since it is an inner join. If we wished to include the names of such manufacturers in the result, we could write the query as follows:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"SELECT m.name AS mname, pname\n  FROM manufacturers m LEFT JOIN LATERAL get_product_names(m.id) pname ON true;\n"})}),"\n",(0,t.jsx)(n.h2,{id:"compatibility",children:"Compatibility"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"SELECT"})," statement is compatible with the SQL standard, but there are some extensions and some missing features."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Omitted FROM Clauses"})}),"\n",(0,t.jsxs)(n.p,{children:["Cloudberry Database allows one to omit the ",(0,t.jsx)(n.code,{children:"FROM"})," clause. It has a straightforward use to compute the results of simple expressions. For example:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"SELECT 2+2;\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Some other SQL databases cannot do this except by introducing a dummy one-row table from which to do the ",(0,t.jsx)(n.code,{children:"SELECT"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Note that if a ",(0,t.jsx)(n.code,{children:"FROM"})," clause is not specified, the query cannot reference any database tables. For example, the following query is invalid:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"SELECT distributors.* WHERE distributors.name = 'Westward';\n"})}),"\n",(0,t.jsxs)(n.p,{children:["In earlier releases, setting a server configuration parameter, ",(0,t.jsx)(n.code,{children:"add_missing_from"}),", to true allowed Cloudberry Database to add an implicit entry to the query's ",(0,t.jsx)(n.code,{children:"FROM"})," clause for each table referenced by the query. This is no longer allowed."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Empty SELECT Lists"})}),"\n",(0,t.jsxs)(n.p,{children:["The list of output expressions after ",(0,t.jsx)(n.code,{children:"SELECT"})," can be empty, producing a zero-column result table. This is not valid syntax according to the SQL standard. Cloudberry Database allows it to be consistent with allowing zero-column tables. However, an empty list is not allowed when ",(0,t.jsx)(n.code,{children:"DISTINCT"})," is used."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Omitting the AS Key Word"})}),"\n",(0,t.jsxs)(n.p,{children:["In the SQL standard, the optional key word ",(0,t.jsx)(n.code,{children:"AS"})," can be omitted before an output column name whenever the new column name is a valid column name (that is, not the same as any reserved keyword). Cloudberry Database is slightly more restrictive: ",(0,t.jsx)(n.code,{children:"AS"})," is required if the new column name matches any keyword at all, reserved or not. Recommended practice is to use ",(0,t.jsx)(n.code,{children:"AS"})," or double-quote output column names, to prevent any possible conflict against future keyword additions."]}),"\n",(0,t.jsxs)(n.p,{children:["In ",(0,t.jsx)(n.code,{children:"FROM"})," items, both the standard and Cloudberry Database allow ",(0,t.jsx)(n.code,{children:"AS"})," to be omitted before an alias that is an unreserved keyword. But this is impractical for output column names, because of syntactic ambiguities."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"ONLY and Inheritance"})}),"\n",(0,t.jsxs)(n.p,{children:["The SQL standard requires parentheses around the table name when writing ",(0,t.jsx)(n.code,{children:"ONLY"}),", for example:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"SELECT * FROM ONLY (tab1), ONLY (tab2) WHERE ...\n"})}),"\n",(0,t.jsx)(n.p,{children:"Cloudberry Database considers these parentheses to be optional."}),"\n",(0,t.jsxs)(n.p,{children:["Cloudberry Database allows a trailing ",(0,t.jsx)(n.code,{children:"*"})," to be written to explicitly specify the non-",(0,t.jsx)(n.code,{children:"ONLY"})," behavior of including child tables. The standard does not allow this."]}),"\n",(0,t.jsxs)(n.p,{children:["Note: The above points apply equally to all SQL commands supporting the ",(0,t.jsx)(n.code,{children:"ONLY"})," option."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"TABLESAMPLE Clause Restrictions"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"TABLESAMPLE"})," clause is currently accepted only on regular tables and materialized views. According to the SQL standard it should be possible to apply it to any ",(0,t.jsx)(n.code,{children:"FROM"})," item."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Function Calls in FROM"})}),"\n",(0,t.jsxs)(n.p,{children:["Cloudberry Database allows you to write a function call directly as a member of the ",(0,t.jsx)(n.code,{children:"FROM"})," list. In the SQL standard it would be necessary to wrap such a function call in a sub-",(0,t.jsx)(n.code,{children:"SELECT"}),"; that is, the syntax ",(0,t.jsx)(n.code,{children:"FROM func(...) alias"})," is approximately equivalent to ",(0,t.jsx)(n.code,{children:"FROM LATERAL (SELECT func(...)) alias"}),". Note that ",(0,t.jsx)(n.code,{children:"LATERAL"})," is considered to be implicit; this is because the standard requires ",(0,t.jsx)(n.code,{children:"LATERAL"})," semantics for an ",(0,t.jsx)(n.code,{children:"UNNEST()"})," item in ",(0,t.jsx)(n.code,{children:"FROM"}),". Cloudberry Database treats ",(0,t.jsx)(n.code,{children:"UNNEST()"})," the same as other set-returning functions."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Namespace Available to GROUP BY and ORDER BY"})}),"\n",(0,t.jsxs)(n.p,{children:["In the SQL-92 standard, an ",(0,t.jsx)(n.code,{children:"ORDER BY"})," clause may only use output column names or numbers, while a ",(0,t.jsx)(n.code,{children:"GROUP BY"})," clause may only use expressions based on input column names. Cloudberry Database extends each of these clauses to allow the other choice as well (but it uses the standard's interpretation if there is ambiguity). Cloudberry Database also allows both clauses to specify arbitrary expressions. Note that names appearing in an expression are always taken as input-column names, not as output column names."]}),"\n",(0,t.jsxs)(n.p,{children:["SQL:1999 and later use a slightly different definition which is not entirely upward compatible with SQL-92. In most cases, however, Cloudberry Database interprets an ",(0,t.jsx)(n.code,{children:"ORDER BY"})," or ",(0,t.jsx)(n.code,{children:"GROUP BY"})," expression the same way SQL:1999 does."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Functional Dependencies"})}),"\n",(0,t.jsxs)(n.p,{children:["Cloudberry Database recognizes functional dependency (allowing columns to be omitted from ",(0,t.jsx)(n.code,{children:"GROUP BY"}),") only when a table's primary key is included in the ",(0,t.jsx)(n.code,{children:"GROUP BY"})," list. The SQL standard specifies additional conditions that should be recognized."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"LIMIT and OFFSET"})}),"\n",(0,t.jsxs)(n.p,{children:["The clauses ",(0,t.jsx)(n.code,{children:"LIMIT"})," and ",(0,t.jsx)(n.code,{children:"OFFSET"})," are Cloudberry Database-specific syntax, also used by MySQL. The SQL:2008 standard has introduced the clauses ",(0,t.jsx)(n.code,{children:"OFFSET .. FETCH {FIRST|NEXT} ..."})," for the same functionality, as shown above in ",(0,t.jsx)(n.a,{href:"#limitclause",children:"LIMIT Clause"}),". This syntax is also used by IBM DB2. (Applications for Oracle frequently use a workaround involving the automatically generated ",(0,t.jsx)(n.code,{children:"rownum"})," column, which is not available in Cloudberry Database, to implement the effects of these clauses.)"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"FOR NO KEY UPDATE, FOR UPDATE, FOR SHARE, and FOR KEY SHARE"})}),"\n",(0,t.jsxs)(n.p,{children:["Although ",(0,t.jsx)(n.code,{children:"FOR UPDATE"})," appears in the SQL standard, the standard allows it only as an option of ",(0,t.jsx)(n.code,{children:"DECLARE CURSOR"}),". Cloudberry Database allows it in any ",(0,t.jsx)(n.code,{children:"SELECT"})," query as well as in sub-",(0,t.jsx)(n.code,{children:"SELECT"}),"s, but this is an extension. The ",(0,t.jsx)(n.code,{children:"FOR NO KEY UPDATE"}),", ",(0,t.jsx)(n.code,{children:"FOR SHARE"}),", and ",(0,t.jsx)(n.code,{children:"FOR KEY SHARE"})," variants, as well as the ",(0,t.jsx)(n.code,{children:"NOWAIT"})," and ",(0,t.jsx)(n.code,{children:"SKIP LOCKED"})," options, do not appear in the standard."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Data-Modifying Statements in WITH"})}),"\n",(0,t.jsxs)(n.p,{children:["Cloudberry Database allows ",(0,t.jsx)(n.code,{children:"INSERT"}),", ",(0,t.jsx)(n.code,{children:"UPDATE"}),", and ",(0,t.jsx)(n.code,{children:"DELETE"})," to be used as ",(0,t.jsx)(n.code,{children:"WITH"})," queries. This is not found in the SQL standard."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Nonstandard Clauses"})}),"\n",(0,t.jsxs)(n.p,{children:["The clause ",(0,t.jsx)(n.code,{children:"DISTINCT ON"})," is not defined in the SQL standard."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"ROWS FROM( ... )"})," is an extension of the SQL standard."]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"MATERIALIZED"})," and ",(0,t.jsx)(n.code,{children:"NOT MATERIALIZED"})," options of ",(0,t.jsx)(n.code,{children:"WITH"})," are extensions of the SQL standard."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Limited Use of STABLE and VOLATILE Functions"})}),"\n",(0,t.jsxs)(n.p,{children:["To prevent data from becoming out-of-sync across the segments in Cloudberry Database, any function classified as ",(0,t.jsx)(n.code,{children:"STABLE"})," or ",(0,t.jsx)(n.code,{children:"VOLATILE"})," cannot be run at the segment database level if it contains SQL or modifies the database in any way. See ",(0,t.jsx)(n.a,{href:"/docs/sql-stmts/create-function",children:"CREATE FUNCTION"})," for more information."]}),"\n",(0,t.jsx)(n.h2,{id:"see-also",children:"See also"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"/docs/sql-stmts/explain",children:"EXPLAIN"})})]})}function h(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},11151:(e,n,s)=>{s.d(n,{Z:()=>c,a:()=>r});var t=s(67294);const i={},o=t.createContext(i);function r(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);